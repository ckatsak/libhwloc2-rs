/* automatically generated by rust-bindgen 0.59.2 */

pub const HWLOC_VERSION: &[u8; 6usize] = b"2.7.1\0";
pub const HWLOC_VERSION_MAJOR: u32 = 2;
pub const HWLOC_VERSION_MINOR: u32 = 7;
pub const HWLOC_VERSION_RELEASE: u32 = 1;
pub const HWLOC_VERSION_GREEK: &[u8; 1usize] = b"\0";
pub const HWLOC_LINUX_SYS: u32 = 1;
pub const HWLOC_HAVE_CPU_SET: u32 = 1;
pub const HWLOC_HAVE_STDINT_H: u32 = 1;
pub const HWLOC_SYM_TRANSFORM: u32 = 0;
pub const HWLOC_API_VERSION: u32 = 132352;
pub const HWLOC_COMPONENT_ABI: u32 = 7;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __pid_t = ::std::os::raw::c_int;
pub type size_t = ::std::os::raw::c_ulong;
pub type pid_t = __pid_t;
pub type pthread_t = ::std::os::raw::c_ulong;
pub type hwloc_uint64_t = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hwloc_bitmap_s {
    _unused: [u8; 0],
}
#[doc = " \\brief"]
#[doc = " Set of bits represented as an opaque pointer to an internal bitmap."]
pub type hwloc_bitmap_t = *mut hwloc_bitmap_s;
#[doc = " \\brief a non-modifiable ::hwloc_bitmap_t"]
pub type hwloc_const_bitmap_t = *const hwloc_bitmap_s;
extern "C" {
    #[doc = " \\brief Allocate a new empty bitmap."]
    #[doc = ""]
    #[doc = " \\returns A valid bitmap or \\c NULL."]
    #[doc = ""]
    #[doc = " The bitmap should be freed by a corresponding call to"]
    #[doc = " hwloc_bitmap_free()."]
    pub fn hwloc_bitmap_alloc() -> hwloc_bitmap_t;
}
extern "C" {
    #[doc = " \\brief Allocate a new full bitmap."]
    pub fn hwloc_bitmap_alloc_full() -> hwloc_bitmap_t;
}
extern "C" {
    #[doc = " \\brief Free bitmap \\p bitmap."]
    #[doc = ""]
    #[doc = " If \\p bitmap is \\c NULL, no operation is performed."]
    pub fn hwloc_bitmap_free(bitmap: hwloc_bitmap_t);
}
extern "C" {
    #[doc = " \\brief Duplicate bitmap \\p bitmap by allocating a new bitmap and copying \\p bitmap contents."]
    #[doc = ""]
    #[doc = " If \\p bitmap is \\c NULL, \\c NULL is returned."]
    pub fn hwloc_bitmap_dup(bitmap: hwloc_const_bitmap_t) -> hwloc_bitmap_t;
}
extern "C" {
    #[doc = " \\brief Copy the contents of bitmap \\p src into the already allocated bitmap \\p dst"]
    pub fn hwloc_bitmap_copy(
        dst: hwloc_bitmap_t,
        src: hwloc_const_bitmap_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Stringify a bitmap."]
    #[doc = ""]
    #[doc = " Up to \\p buflen characters may be written in buffer \\p buf."]
    #[doc = ""]
    #[doc = " If \\p buflen is 0, \\p buf may safely be \\c NULL."]
    #[doc = ""]
    #[doc = " \\return the number of character that were actually written if not truncating,"]
    #[doc = " or that would have been written (not including the ending \\\\0)."]
    pub fn hwloc_bitmap_snprintf(
        buf: *mut ::std::os::raw::c_char,
        buflen: size_t,
        bitmap: hwloc_const_bitmap_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Stringify a bitmap into a newly allocated string."]
    #[doc = ""]
    #[doc = " \\return -1 on error."]
    pub fn hwloc_bitmap_asprintf(
        strp: *mut *mut ::std::os::raw::c_char,
        bitmap: hwloc_const_bitmap_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Parse a bitmap string and stores it in bitmap \\p bitmap."]
    pub fn hwloc_bitmap_sscanf(
        bitmap: hwloc_bitmap_t,
        string: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Stringify a bitmap in the list format."]
    #[doc = ""]
    #[doc = " Lists are comma-separated indexes or ranges."]
    #[doc = " Ranges are dash separated indexes."]
    #[doc = " The last range may not have an ending indexes if the bitmap is infinitely set."]
    #[doc = ""]
    #[doc = " Up to \\p buflen characters may be written in buffer \\p buf."]
    #[doc = ""]
    #[doc = " If \\p buflen is 0, \\p buf may safely be \\c NULL."]
    #[doc = ""]
    #[doc = " \\return the number of character that were actually written if not truncating,"]
    #[doc = " or that would have been written (not including the ending \\\\0)."]
    pub fn hwloc_bitmap_list_snprintf(
        buf: *mut ::std::os::raw::c_char,
        buflen: size_t,
        bitmap: hwloc_const_bitmap_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Stringify a bitmap into a newly allocated list string."]
    #[doc = ""]
    #[doc = " \\return -1 on error."]
    pub fn hwloc_bitmap_list_asprintf(
        strp: *mut *mut ::std::os::raw::c_char,
        bitmap: hwloc_const_bitmap_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Parse a list string and stores it in bitmap \\p bitmap."]
    pub fn hwloc_bitmap_list_sscanf(
        bitmap: hwloc_bitmap_t,
        string: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Stringify a bitmap in the taskset-specific format."]
    #[doc = ""]
    #[doc = " The taskset command manipulates bitmap strings that contain a single"]
    #[doc = " (possible very long) hexadecimal number starting with 0x."]
    #[doc = ""]
    #[doc = " Up to \\p buflen characters may be written in buffer \\p buf."]
    #[doc = ""]
    #[doc = " If \\p buflen is 0, \\p buf may safely be \\c NULL."]
    #[doc = ""]
    #[doc = " \\return the number of character that were actually written if not truncating,"]
    #[doc = " or that would have been written (not including the ending \\\\0)."]
    pub fn hwloc_bitmap_taskset_snprintf(
        buf: *mut ::std::os::raw::c_char,
        buflen: size_t,
        bitmap: hwloc_const_bitmap_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Stringify a bitmap into a newly allocated taskset-specific string."]
    #[doc = ""]
    #[doc = " \\return -1 on error."]
    pub fn hwloc_bitmap_taskset_asprintf(
        strp: *mut *mut ::std::os::raw::c_char,
        bitmap: hwloc_const_bitmap_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Parse a taskset-specific bitmap string and stores it in bitmap \\p bitmap."]
    pub fn hwloc_bitmap_taskset_sscanf(
        bitmap: hwloc_bitmap_t,
        string: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Empty the bitmap \\p bitmap"]
    pub fn hwloc_bitmap_zero(bitmap: hwloc_bitmap_t);
}
extern "C" {
    #[doc = " \\brief Fill bitmap \\p bitmap with all possible indexes (even if those objects don't exist or are otherwise unavailable)"]
    pub fn hwloc_bitmap_fill(bitmap: hwloc_bitmap_t);
}
extern "C" {
    #[doc = " \\brief Empty the bitmap \\p bitmap and add bit \\p id"]
    pub fn hwloc_bitmap_only(
        bitmap: hwloc_bitmap_t,
        id: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Fill the bitmap \\p and clear the index \\p id"]
    pub fn hwloc_bitmap_allbut(
        bitmap: hwloc_bitmap_t,
        id: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Setup bitmap \\p bitmap from unsigned long \\p mask"]
    pub fn hwloc_bitmap_from_ulong(
        bitmap: hwloc_bitmap_t,
        mask: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Setup bitmap \\p bitmap from unsigned long \\p mask used as \\p i -th subset"]
    pub fn hwloc_bitmap_from_ith_ulong(
        bitmap: hwloc_bitmap_t,
        i: ::std::os::raw::c_uint,
        mask: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Setup bitmap \\p bitmap from unsigned longs \\p masks used as first \\p nr subsets"]
    pub fn hwloc_bitmap_from_ulongs(
        bitmap: hwloc_bitmap_t,
        nr: ::std::os::raw::c_uint,
        masks: *const ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Add index \\p id in bitmap \\p bitmap"]
    pub fn hwloc_bitmap_set(
        bitmap: hwloc_bitmap_t,
        id: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Add indexes from \\p begin to \\p end in bitmap \\p bitmap."]
    #[doc = ""]
    #[doc = " If \\p end is \\c -1, the range is infinite."]
    pub fn hwloc_bitmap_set_range(
        bitmap: hwloc_bitmap_t,
        begin: ::std::os::raw::c_uint,
        end: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Replace \\p i -th subset of bitmap \\p bitmap with unsigned long \\p mask"]
    pub fn hwloc_bitmap_set_ith_ulong(
        bitmap: hwloc_bitmap_t,
        i: ::std::os::raw::c_uint,
        mask: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Remove index \\p id from bitmap \\p bitmap"]
    pub fn hwloc_bitmap_clr(
        bitmap: hwloc_bitmap_t,
        id: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Remove indexes from \\p begin to \\p end in bitmap \\p bitmap."]
    #[doc = ""]
    #[doc = " If \\p end is \\c -1, the range is infinite."]
    pub fn hwloc_bitmap_clr_range(
        bitmap: hwloc_bitmap_t,
        begin: ::std::os::raw::c_uint,
        end: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Keep a single index among those set in bitmap \\p bitmap"]
    #[doc = ""]
    #[doc = " May be useful before binding so that the process does not"]
    #[doc = " have a chance of migrating between multiple processors"]
    #[doc = " in the original mask."]
    #[doc = " Instead of running the task on any PU inside the given CPU set,"]
    #[doc = " the operating system scheduler will be forced to run it on a single"]
    #[doc = " of these PUs."]
    #[doc = " It avoids a migration overhead and cache-line ping-pongs between PUs."]
    #[doc = ""]
    #[doc = " \\note This function is NOT meant to distribute multiple processes"]
    #[doc = " within a single CPU set. It always return the same single bit when"]
    #[doc = " called multiple times on the same input set. hwloc_distrib() may"]
    #[doc = " be used for generating CPU sets to distribute multiple tasks below"]
    #[doc = " a single multi-PU object."]
    #[doc = ""]
    #[doc = " \\note This function cannot be applied to an object set directly. It"]
    #[doc = " should be applied to a copy (which may be obtained with hwloc_bitmap_dup())."]
    pub fn hwloc_bitmap_singlify(bitmap: hwloc_bitmap_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Convert the beginning part of bitmap \\p bitmap into unsigned long \\p mask"]
    pub fn hwloc_bitmap_to_ulong(bitmap: hwloc_const_bitmap_t) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " \\brief Convert the \\p i -th subset of bitmap \\p bitmap into unsigned long mask"]
    pub fn hwloc_bitmap_to_ith_ulong(
        bitmap: hwloc_const_bitmap_t,
        i: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " \\brief Convert the first \\p nr subsets of bitmap \\p bitmap into the array of \\p nr unsigned long \\p masks"]
    #[doc = ""]
    #[doc = " \\p nr may be determined earlier with hwloc_bitmap_nr_ulongs()."]
    #[doc = ""]
    #[doc = " \\return 0"]
    pub fn hwloc_bitmap_to_ulongs(
        bitmap: hwloc_const_bitmap_t,
        nr: ::std::os::raw::c_uint,
        masks: *mut ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Return the number of unsigned longs required for storing bitmap \\p bitmap entirely"]
    #[doc = ""]
    #[doc = " This is the number of contiguous unsigned longs from the very first bit of the bitmap"]
    #[doc = " (even if unset) up to the last set bit."]
    #[doc = " This is useful for knowing the \\p nr parameter to pass to hwloc_bitmap_to_ulongs()"]
    #[doc = " (or which calls to hwloc_bitmap_to_ith_ulong() are needed)"]
    #[doc = " to entirely convert a bitmap into multiple unsigned longs."]
    #[doc = ""]
    #[doc = " When called on the output of hwloc_topology_get_topology_cpuset(),"]
    #[doc = " the returned number is large enough for all cpusets of the topology."]
    #[doc = ""]
    #[doc = " \\return -1 if \\p bitmap is infinite."]
    pub fn hwloc_bitmap_nr_ulongs(bitmap: hwloc_const_bitmap_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Test whether index \\p id is part of bitmap \\p bitmap."]
    #[doc = ""]
    #[doc = " \\return 1 if the bit at index \\p id is set in bitmap \\p bitmap, 0 otherwise."]
    pub fn hwloc_bitmap_isset(
        bitmap: hwloc_const_bitmap_t,
        id: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Test whether bitmap \\p bitmap is empty"]
    #[doc = ""]
    #[doc = " \\return 1 if bitmap is empty, 0 otherwise."]
    pub fn hwloc_bitmap_iszero(bitmap: hwloc_const_bitmap_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Test whether bitmap \\p bitmap is completely full"]
    #[doc = ""]
    #[doc = " \\return 1 if bitmap is full, 0 otherwise."]
    #[doc = ""]
    #[doc = " \\note A full bitmap is always infinitely set."]
    pub fn hwloc_bitmap_isfull(bitmap: hwloc_const_bitmap_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Compute the first index (least significant bit) in bitmap \\p bitmap"]
    #[doc = ""]
    #[doc = " \\return -1 if no index is set in \\p bitmap."]
    pub fn hwloc_bitmap_first(bitmap: hwloc_const_bitmap_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Compute the next index in bitmap \\p bitmap which is after index \\p prev"]
    #[doc = ""]
    #[doc = " If \\p prev is -1, the first index is returned."]
    #[doc = ""]
    #[doc = " \\return -1 if no index with higher index is set in \\p bitmap."]
    pub fn hwloc_bitmap_next(
        bitmap: hwloc_const_bitmap_t,
        prev: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Compute the last index (most significant bit) in bitmap \\p bitmap"]
    #[doc = ""]
    #[doc = " \\return -1 if no index is set in \\p bitmap, or if \\p bitmap is infinitely set."]
    pub fn hwloc_bitmap_last(bitmap: hwloc_const_bitmap_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Compute the \"weight\" of bitmap \\p bitmap (i.e., number of"]
    #[doc = " indexes that are in the bitmap)."]
    #[doc = ""]
    #[doc = " \\return the number of indexes that are in the bitmap."]
    #[doc = ""]
    #[doc = " \\return -1 if \\p bitmap is infinitely set."]
    pub fn hwloc_bitmap_weight(bitmap: hwloc_const_bitmap_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Compute the first unset index (least significant bit) in bitmap \\p bitmap"]
    #[doc = ""]
    #[doc = " \\return -1 if no index is unset in \\p bitmap."]
    pub fn hwloc_bitmap_first_unset(bitmap: hwloc_const_bitmap_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Compute the next unset index in bitmap \\p bitmap which is after index \\p prev"]
    #[doc = ""]
    #[doc = " If \\p prev is -1, the first unset index is returned."]
    #[doc = ""]
    #[doc = " \\return -1 if no index with higher index is unset in \\p bitmap."]
    pub fn hwloc_bitmap_next_unset(
        bitmap: hwloc_const_bitmap_t,
        prev: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Compute the last unset index (most significant bit) in bitmap \\p bitmap"]
    #[doc = ""]
    #[doc = " \\return -1 if no index is unset in \\p bitmap, or if \\p bitmap is infinitely set."]
    pub fn hwloc_bitmap_last_unset(bitmap: hwloc_const_bitmap_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Or bitmaps \\p bitmap1 and \\p bitmap2 and store the result in bitmap \\p res"]
    #[doc = ""]
    #[doc = " \\p res can be the same as \\p bitmap1 or \\p bitmap2"]
    pub fn hwloc_bitmap_or(
        res: hwloc_bitmap_t,
        bitmap1: hwloc_const_bitmap_t,
        bitmap2: hwloc_const_bitmap_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief And bitmaps \\p bitmap1 and \\p bitmap2 and store the result in bitmap \\p res"]
    #[doc = ""]
    #[doc = " \\p res can be the same as \\p bitmap1 or \\p bitmap2"]
    pub fn hwloc_bitmap_and(
        res: hwloc_bitmap_t,
        bitmap1: hwloc_const_bitmap_t,
        bitmap2: hwloc_const_bitmap_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief And bitmap \\p bitmap1 and the negation of \\p bitmap2 and store the result in bitmap \\p res"]
    #[doc = ""]
    #[doc = " \\p res can be the same as \\p bitmap1 or \\p bitmap2"]
    pub fn hwloc_bitmap_andnot(
        res: hwloc_bitmap_t,
        bitmap1: hwloc_const_bitmap_t,
        bitmap2: hwloc_const_bitmap_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Xor bitmaps \\p bitmap1 and \\p bitmap2 and store the result in bitmap \\p res"]
    #[doc = ""]
    #[doc = " \\p res can be the same as \\p bitmap1 or \\p bitmap2"]
    pub fn hwloc_bitmap_xor(
        res: hwloc_bitmap_t,
        bitmap1: hwloc_const_bitmap_t,
        bitmap2: hwloc_const_bitmap_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Negate bitmap \\p bitmap and store the result in bitmap \\p res"]
    #[doc = ""]
    #[doc = " \\p res can be the same as \\p bitmap"]
    pub fn hwloc_bitmap_not(
        res: hwloc_bitmap_t,
        bitmap: hwloc_const_bitmap_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Test whether bitmaps \\p bitmap1 and \\p bitmap2 intersects."]
    #[doc = ""]
    #[doc = " \\return 1 if bitmaps intersect, 0 otherwise."]
    pub fn hwloc_bitmap_intersects(
        bitmap1: hwloc_const_bitmap_t,
        bitmap2: hwloc_const_bitmap_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Test whether bitmap \\p sub_bitmap is part of bitmap \\p super_bitmap."]
    #[doc = ""]
    #[doc = " \\return 1 if \\p sub_bitmap is included in \\p super_bitmap, 0 otherwise."]
    #[doc = ""]
    #[doc = " \\note The empty bitmap is considered included in any other bitmap."]
    pub fn hwloc_bitmap_isincluded(
        sub_bitmap: hwloc_const_bitmap_t,
        super_bitmap: hwloc_const_bitmap_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Test whether bitmap \\p bitmap1 is equal to bitmap \\p bitmap2."]
    #[doc = ""]
    #[doc = " \\return 1 if bitmaps are equal, 0 otherwise."]
    pub fn hwloc_bitmap_isequal(
        bitmap1: hwloc_const_bitmap_t,
        bitmap2: hwloc_const_bitmap_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Compare bitmaps \\p bitmap1 and \\p bitmap2 using their lowest index."]
    #[doc = ""]
    #[doc = " A bitmap is considered smaller if its least significant bit is smaller."]
    #[doc = " The empty bitmap is considered higher than anything (because its least significant bit does not exist)."]
    #[doc = ""]
    #[doc = " \\return -1 if \\p bitmap1 is considered smaller than \\p bitmap2."]
    #[doc = " \\return 1 if \\p bitmap1 is considered larger than \\p bitmap2."]
    #[doc = ""]
    #[doc = " For instance comparing binary bitmaps 0011 and 0110 returns -1"]
    #[doc = " (hence 0011 is considered smaller than 0110)"]
    #[doc = " because least significant bit of 0011 (0001) is smaller than least significant bit of 0110 (0010)."]
    #[doc = " Comparing 01001 and 00110 would also return -1 for the same reason."]
    #[doc = ""]
    #[doc = " \\return 0 if bitmaps are considered equal, even if they are not strictly equal."]
    #[doc = " They just need to have the same least significant bit."]
    #[doc = " For instance, comparing binary bitmaps 0010 and 0110 returns 0 because they have the same least significant bit."]
    pub fn hwloc_bitmap_compare_first(
        bitmap1: hwloc_const_bitmap_t,
        bitmap2: hwloc_const_bitmap_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Compare bitmaps \\p bitmap1 and \\p bitmap2 in lexicographic order."]
    #[doc = ""]
    #[doc = " Lexicographic comparison of bitmaps, starting for their highest indexes."]
    #[doc = " Compare last indexes first, then second, etc."]
    #[doc = " The empty bitmap is considered lower than anything."]
    #[doc = ""]
    #[doc = " \\return -1 if \\p bitmap1 is considered smaller than \\p bitmap2."]
    #[doc = " \\return 1 if \\p bitmap1 is considered larger than \\p bitmap2."]
    #[doc = " \\return 0 if bitmaps are equal (contrary to hwloc_bitmap_compare_first())."]
    #[doc = ""]
    #[doc = " For instance comparing binary bitmaps 0011 and 0110 returns -1"]
    #[doc = " (hence 0011 is considered smaller than 0110)."]
    #[doc = " Comparing 00101 and 01010 returns -1 too."]
    #[doc = ""]
    #[doc = " \\note This is different from the non-existing hwloc_bitmap_compare_last()"]
    #[doc = " which would only compare the highest index of each bitmap."]
    pub fn hwloc_bitmap_compare(
        bitmap1: hwloc_const_bitmap_t,
        bitmap2: hwloc_const_bitmap_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Indicate at runtime which hwloc API version was used at build time."]
    #[doc = ""]
    #[doc = " Should be ::HWLOC_API_VERSION if running on the same version."]
    pub fn hwloc_get_api_version() -> ::std::os::raw::c_uint;
}
#[doc = " \\brief A CPU set is a bitmap whose bits are set according to CPU"]
#[doc = " physical OS indexes."]
#[doc = ""]
#[doc = " It may be consulted and modified with the bitmap API as any"]
#[doc = " ::hwloc_bitmap_t (see hwloc/bitmap.h)."]
#[doc = ""]
#[doc = " Each bit may be converted into a PU object using"]
#[doc = " hwloc_get_pu_obj_by_os_index()."]
pub type hwloc_cpuset_t = hwloc_bitmap_t;
#[doc = " \\brief A non-modifiable ::hwloc_cpuset_t."]
pub type hwloc_const_cpuset_t = hwloc_const_bitmap_t;
#[doc = " \\brief A node set is a bitmap whose bits are set according to NUMA"]
#[doc = " memory node physical OS indexes."]
#[doc = ""]
#[doc = " It may be consulted and modified with the bitmap API as any"]
#[doc = " ::hwloc_bitmap_t (see hwloc/bitmap.h)."]
#[doc = " Each bit may be converted into a NUMA node object using"]
#[doc = " hwloc_get_numanode_obj_by_os_index()."]
#[doc = ""]
#[doc = " When binding memory on a system without any NUMA node,"]
#[doc = " the single main memory bank is considered as NUMA node #0."]
#[doc = ""]
#[doc = " See also \\ref hwlocality_helper_nodeset_convert."]
pub type hwloc_nodeset_t = hwloc_bitmap_t;
#[doc = " \\brief A non-modifiable ::hwloc_nodeset_t."]
pub type hwloc_const_nodeset_t = hwloc_const_bitmap_t;
#[doc = "< \\brief Machine."]
#[doc = " A set of processors and memory with cache"]
#[doc = " coherency."]
#[doc = ""]
#[doc = " This type is always used for the root object of a topology,"]
#[doc = " and never used anywhere else."]
#[doc = " Hence its parent is always \\c NULL."]
pub const hwloc_obj_type_t_HWLOC_OBJ_MACHINE: hwloc_obj_type_t = 0;
#[doc = "< \\brief Physical package."]
#[doc = " The physical package that usually gets inserted"]
#[doc = " into a socket on the motherboard."]
#[doc = " A processor package usually contains multiple cores,"]
#[doc = " and possibly some dies."]
pub const hwloc_obj_type_t_HWLOC_OBJ_PACKAGE: hwloc_obj_type_t = 1;
#[doc = "< \\brief Core."]
#[doc = " A computation unit (may be shared by several"]
#[doc = " PUs, aka logical processors)."]
pub const hwloc_obj_type_t_HWLOC_OBJ_CORE: hwloc_obj_type_t = 2;
#[doc = "< \\brief Processing Unit, or (Logical) Processor."]
#[doc = " An execution unit (may share a core with some"]
#[doc = " other logical processors, e.g. in the case of"]
#[doc = " an SMT core)."]
#[doc = ""]
#[doc = " This is the smallest object representing CPU resources,"]
#[doc = " it cannot have any child except Misc objects."]
#[doc = ""]
#[doc = " Objects of this kind are always reported and can"]
#[doc = " thus be used as fallback when others are not."]
pub const hwloc_obj_type_t_HWLOC_OBJ_PU: hwloc_obj_type_t = 3;
#[doc = "< \\brief Level 1 Data (or Unified) Cache."]
pub const hwloc_obj_type_t_HWLOC_OBJ_L1CACHE: hwloc_obj_type_t = 4;
#[doc = "< \\brief Level 2 Data (or Unified) Cache."]
pub const hwloc_obj_type_t_HWLOC_OBJ_L2CACHE: hwloc_obj_type_t = 5;
#[doc = "< \\brief Level 3 Data (or Unified) Cache."]
pub const hwloc_obj_type_t_HWLOC_OBJ_L3CACHE: hwloc_obj_type_t = 6;
#[doc = "< \\brief Level 4 Data (or Unified) Cache."]
pub const hwloc_obj_type_t_HWLOC_OBJ_L4CACHE: hwloc_obj_type_t = 7;
#[doc = "< \\brief Level 5 Data (or Unified) Cache."]
pub const hwloc_obj_type_t_HWLOC_OBJ_L5CACHE: hwloc_obj_type_t = 8;
#[doc = "< \\brief Level 1 instruction Cache (filtered out by default)."]
pub const hwloc_obj_type_t_HWLOC_OBJ_L1ICACHE: hwloc_obj_type_t = 9;
#[doc = "< \\brief Level 2 instruction Cache (filtered out by default)."]
pub const hwloc_obj_type_t_HWLOC_OBJ_L2ICACHE: hwloc_obj_type_t = 10;
#[doc = "< \\brief Level 3 instruction Cache (filtered out by default)."]
pub const hwloc_obj_type_t_HWLOC_OBJ_L3ICACHE: hwloc_obj_type_t = 11;
#[doc = "< \\brief Group objects."]
#[doc = " Objects which do not fit in the above but are"]
#[doc = " detected by hwloc and are useful to take into"]
#[doc = " account for affinity. For instance, some operating systems"]
#[doc = " expose their arbitrary processors aggregation this"]
#[doc = " way.  And hwloc may insert such objects to group"]
#[doc = " NUMA nodes according to their distances."]
#[doc = " See also \\ref faq_groups."]
#[doc = ""]
#[doc = " These objects are removed when they do not bring"]
#[doc = " any structure (see ::HWLOC_TYPE_FILTER_KEEP_STRUCTURE)."]
pub const hwloc_obj_type_t_HWLOC_OBJ_GROUP: hwloc_obj_type_t = 12;
#[doc = "< \\brief NUMA node."]
#[doc = " An object that contains memory that is directly"]
#[doc = " and byte-accessible to the host processors."]
#[doc = " It is usually close to some cores (the corresponding objects"]
#[doc = " are descendants of the NUMA node object in the hwloc tree)."]
#[doc = ""]
#[doc = " This is the smallest object representing Memory resources,"]
#[doc = " it cannot have any child except Misc objects."]
#[doc = " However it may have Memory-side cache parents."]
#[doc = ""]
#[doc = " There is always at least one such object in the topology"]
#[doc = " even if the machine is not NUMA."]
#[doc = ""]
#[doc = " Memory objects are not listed in the main children list,"]
#[doc = " but rather in the dedicated Memory children list."]
#[doc = ""]
#[doc = " NUMA nodes have a special depth ::HWLOC_TYPE_DEPTH_NUMANODE"]
#[doc = " instead of a normal depth just like other objects in the"]
#[doc = " main tree."]
pub const hwloc_obj_type_t_HWLOC_OBJ_NUMANODE: hwloc_obj_type_t = 13;
#[doc = "< \\brief Bridge (filtered out by default)."]
#[doc = " Any bridge (or PCI switch) that connects the host or an I/O bus,"]
#[doc = " to another I/O bus."]
#[doc = ""]
#[doc = " Bridges are not added to the topology unless their"]
#[doc = " filtering is changed (see hwloc_topology_set_type_filter()"]
#[doc = " and hwloc_topology_set_io_types_filter())."]
#[doc = ""]
#[doc = " I/O objects are not listed in the main children list,"]
#[doc = " but rather in the dedicated io children list."]
#[doc = " I/O objects have NULL CPU and node sets."]
pub const hwloc_obj_type_t_HWLOC_OBJ_BRIDGE: hwloc_obj_type_t = 14;
#[doc = "< \\brief PCI device (filtered out by default)."]
#[doc = ""]
#[doc = " PCI devices are not added to the topology unless their"]
#[doc = " filtering is changed (see hwloc_topology_set_type_filter()"]
#[doc = " and hwloc_topology_set_io_types_filter())."]
#[doc = ""]
#[doc = " I/O objects are not listed in the main children list,"]
#[doc = " but rather in the dedicated io children list."]
#[doc = " I/O objects have NULL CPU and node sets."]
pub const hwloc_obj_type_t_HWLOC_OBJ_PCI_DEVICE: hwloc_obj_type_t = 15;
#[doc = "< \\brief Operating system device (filtered out by default)."]
#[doc = ""]
#[doc = " OS devices are not added to the topology unless their"]
#[doc = " filtering is changed (see hwloc_topology_set_type_filter()"]
#[doc = " and hwloc_topology_set_io_types_filter())."]
#[doc = ""]
#[doc = " I/O objects are not listed in the main children list,"]
#[doc = " but rather in the dedicated io children list."]
#[doc = " I/O objects have NULL CPU and node sets."]
pub const hwloc_obj_type_t_HWLOC_OBJ_OS_DEVICE: hwloc_obj_type_t = 16;
#[doc = "< \\brief Miscellaneous objects (filtered out by default)."]
#[doc = " Objects without particular meaning, that can e.g. be"]
#[doc = " added by the application for its own use, or by hwloc"]
#[doc = " for miscellaneous objects such as MemoryModule (DIMMs)."]
#[doc = ""]
#[doc = " They are not added to the topology unless their filtering"]
#[doc = " is changed (see hwloc_topology_set_type_filter())."]
#[doc = ""]
#[doc = " These objects are not listed in the main children list,"]
#[doc = " but rather in the dedicated misc children list."]
#[doc = " Misc objects may only have Misc objects as children,"]
#[doc = " and those are in the dedicated misc children list as well."]
#[doc = " Misc objects have NULL CPU and node sets."]
pub const hwloc_obj_type_t_HWLOC_OBJ_MISC: hwloc_obj_type_t = 17;
#[doc = "< \\brief Memory-side cache (filtered out by default)."]
#[doc = " A cache in front of a specific NUMA node."]
#[doc = ""]
#[doc = " This object always has at least one NUMA node as a memory child."]
#[doc = ""]
#[doc = " Memory objects are not listed in the main children list,"]
#[doc = " but rather in the dedicated Memory children list."]
#[doc = ""]
#[doc = " Memory-side cache have a special depth ::HWLOC_TYPE_DEPTH_MEMCACHE"]
#[doc = " instead of a normal depth just like other objects in the"]
#[doc = " main tree."]
pub const hwloc_obj_type_t_HWLOC_OBJ_MEMCACHE: hwloc_obj_type_t = 18;
#[doc = "< \\brief Die within a physical package."]
#[doc = " A subpart of the physical package, that contains multiple cores."]
pub const hwloc_obj_type_t_HWLOC_OBJ_DIE: hwloc_obj_type_t = 19;
#[doc = "< \\private Sentinel value"]
pub const hwloc_obj_type_t_HWLOC_OBJ_TYPE_MAX: hwloc_obj_type_t = 20;
#[doc = " \\brief Type of topology object."]
#[doc = ""]
#[doc = " \\note Do not rely on the ordering or completeness of the values as new ones"]
#[doc = " may be defined in the future!  If you need to compare types, use"]
#[doc = " hwloc_compare_types() instead."]
pub type hwloc_obj_type_t = ::std::os::raw::c_uint;
#[doc = "< \\brief Unified cache."]
pub const hwloc_obj_cache_type_e_HWLOC_OBJ_CACHE_UNIFIED: hwloc_obj_cache_type_e = 0;
#[doc = "< \\brief Data cache."]
pub const hwloc_obj_cache_type_e_HWLOC_OBJ_CACHE_DATA: hwloc_obj_cache_type_e = 1;
#[doc = "< \\brief Instruction cache (filtered out by default)."]
pub const hwloc_obj_cache_type_e_HWLOC_OBJ_CACHE_INSTRUCTION: hwloc_obj_cache_type_e = 2;
#[doc = " \\brief Cache type."]
pub type hwloc_obj_cache_type_e = ::std::os::raw::c_uint;
#[doc = " \\brief Cache type."]
pub use self::hwloc_obj_cache_type_e as hwloc_obj_cache_type_t;
#[doc = "< \\brief Host-side of a bridge, only possible upstream."]
pub const hwloc_obj_bridge_type_e_HWLOC_OBJ_BRIDGE_HOST: hwloc_obj_bridge_type_e = 0;
#[doc = "< \\brief PCI-side of a bridge."]
pub const hwloc_obj_bridge_type_e_HWLOC_OBJ_BRIDGE_PCI: hwloc_obj_bridge_type_e = 1;
#[doc = " \\brief Type of one side (upstream or downstream) of an I/O bridge."]
pub type hwloc_obj_bridge_type_e = ::std::os::raw::c_uint;
#[doc = " \\brief Type of one side (upstream or downstream) of an I/O bridge."]
pub use self::hwloc_obj_bridge_type_e as hwloc_obj_bridge_type_t;
#[doc = "< \\brief Operating system block device, or non-volatile memory device."]
#[doc = " For instance \"sda\" or \"dax2.0\" on Linux."]
pub const hwloc_obj_osdev_type_e_HWLOC_OBJ_OSDEV_BLOCK: hwloc_obj_osdev_type_e = 0;
#[doc = "< \\brief Operating system GPU device."]
#[doc = " For instance \":0.0\" for a GL display,"]
#[doc = " \"card0\" for a Linux DRM device."]
pub const hwloc_obj_osdev_type_e_HWLOC_OBJ_OSDEV_GPU: hwloc_obj_osdev_type_e = 1;
#[doc = "< \\brief Operating system network device."]
#[doc = " For instance the \"eth0\" interface on Linux."]
pub const hwloc_obj_osdev_type_e_HWLOC_OBJ_OSDEV_NETWORK: hwloc_obj_osdev_type_e = 2;
#[doc = "< \\brief Operating system openfabrics device."]
#[doc = " For instance the \"mlx4_0\" InfiniBand HCA,"]
#[doc = " \"hfi1_0\" Omni-Path interface,"]
#[doc = " or \"bxi0\" Atos/Bull BXI HCA on Linux."]
pub const hwloc_obj_osdev_type_e_HWLOC_OBJ_OSDEV_OPENFABRICS: hwloc_obj_osdev_type_e = 3;
#[doc = "< \\brief Operating system dma engine device."]
#[doc = " For instance the \"dma0chan0\" DMA channel on Linux."]
pub const hwloc_obj_osdev_type_e_HWLOC_OBJ_OSDEV_DMA: hwloc_obj_osdev_type_e = 4;
#[doc = "< \\brief Operating system co-processor device."]
#[doc = " For instance \"opencl0d0\" for a OpenCL device,"]
#[doc = " \"cuda0\" for a CUDA device."]
pub const hwloc_obj_osdev_type_e_HWLOC_OBJ_OSDEV_COPROC: hwloc_obj_osdev_type_e = 5;
#[doc = " \\brief Type of a OS device."]
pub type hwloc_obj_osdev_type_e = ::std::os::raw::c_uint;
#[doc = " \\brief Type of a OS device."]
pub use self::hwloc_obj_osdev_type_e as hwloc_obj_osdev_type_t;
extern "C" {
    #[doc = " \\brief Compare the depth of two object types"]
    #[doc = ""]
    #[doc = " Types shouldn't be compared as they are, since newer ones may be added in"]
    #[doc = " the future.  This function returns less than, equal to, or greater than zero"]
    #[doc = " respectively if \\p type1 objects usually include \\p type2 objects, are the"]
    #[doc = " same as \\p type2 objects, or are included in \\p type2 objects. If the types"]
    #[doc = " can not be compared (because neither is usually contained in the other),"]
    #[doc = " ::HWLOC_TYPE_UNORDERED is returned.  Object types containing CPUs can always"]
    #[doc = " be compared (usually, a system contains machines which contain nodes which"]
    #[doc = " contain packages which contain caches, which contain cores, which contain"]
    #[doc = " processors)."]
    #[doc = ""]
    #[doc = " \\note ::HWLOC_OBJ_PU will always be the deepest,"]
    #[doc = " while ::HWLOC_OBJ_MACHINE is always the highest."]
    #[doc = ""]
    #[doc = " \\note This does not mean that the actual topology will respect that order:"]
    #[doc = " e.g. as of today cores may also contain caches, and packages may also contain"]
    #[doc = " nodes. This is thus just to be seen as a fallback comparison method."]
    pub fn hwloc_compare_types(
        type1: hwloc_obj_type_t,
        type2: hwloc_obj_type_t,
    ) -> ::std::os::raw::c_int;
}
#[doc = " \\brief Structure of a topology object"]
#[doc = ""]
#[doc = " Applications must not modify any field except \\p hwloc_obj.userdata."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hwloc_obj {
    #[doc = "< \\brief Type of object"]
    pub type_: hwloc_obj_type_t,
    #[doc = "< \\brief Subtype string to better describe the type field."]
    pub subtype: *mut ::std::os::raw::c_char,
    #[doc = "< \\brief OS-provided physical index number."]
    #[doc = " It is not guaranteed unique across the entire machine,"]
    #[doc = " except for PUs and NUMA nodes."]
    #[doc = " Set to HWLOC_UNKNOWN_INDEX if unknown or irrelevant for this object."]
    pub os_index: ::std::os::raw::c_uint,
    #[doc = "< \\brief Object-specific name if any."]
    #[doc = " Mostly used for identifying OS devices and Misc objects where"]
    #[doc = " a name string is more useful than numerical indexes."]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = "< \\brief Total memory (in bytes) in NUMA nodes below this object."]
    pub total_memory: hwloc_uint64_t,
    #[doc = "< \\brief Object type-specific Attributes,"]
    #[doc = " may be \\c NULL if no attribute value was found"]
    pub attr: *mut hwloc_obj_attr_u,
    #[doc = "< \\brief Vertical index in the hierarchy."]
    #[doc = ""]
    #[doc = " For normal objects, this is the depth of the horizontal level"]
    #[doc = " that contains this object and its cousins of the same type."]
    #[doc = " If the topology is symmetric, this is equal to the parent depth"]
    #[doc = " plus one, and also equal to the number of parent/child links"]
    #[doc = " from the root object to here."]
    #[doc = ""]
    #[doc = " For special objects (NUMA nodes, I/O and Misc) that are not"]
    #[doc = " in the main tree, this is a special negative value that"]
    #[doc = " corresponds to their dedicated level,"]
    #[doc = " see hwloc_get_type_depth() and ::hwloc_get_type_depth_e."]
    #[doc = " Those special values can be passed to hwloc functions such"]
    #[doc = " hwloc_get_nbobjs_by_depth() as usual."]
    pub depth: ::std::os::raw::c_int,
    #[doc = "< \\brief Horizontal index in the whole list of similar objects,"]
    #[doc = " hence guaranteed unique across the entire machine."]
    #[doc = " Could be a \"cousin_rank\" since it's the rank within the \"cousin\" list below"]
    #[doc = " Note that this index may change when restricting the topology"]
    #[doc = " or when inserting a group."]
    pub logical_index: ::std::os::raw::c_uint,
    #[doc = "< \\brief Next object of same type and depth"]
    pub next_cousin: *mut hwloc_obj,
    #[doc = "< \\brief Previous object of same type and depth"]
    pub prev_cousin: *mut hwloc_obj,
    #[doc = "< \\brief Parent, \\c NULL if root (Machine object)"]
    pub parent: *mut hwloc_obj,
    #[doc = "< \\brief Index in parent's \\c children[] array. Or the index in parent's Memory, I/O or Misc children list."]
    pub sibling_rank: ::std::os::raw::c_uint,
    #[doc = "< \\brief Next object below the same parent (inside the same list of children)."]
    pub next_sibling: *mut hwloc_obj,
    #[doc = "< \\brief Previous object below the same parent (inside the same list of children)."]
    pub prev_sibling: *mut hwloc_obj,
    #[doc = "< \\brief Number of normal children."]
    #[doc = " Memory, Misc and I/O children are not listed here"]
    #[doc = " but rather in their dedicated children list."]
    pub arity: ::std::os::raw::c_uint,
    #[doc = "< \\brief Normal children, \\c children[0 .. arity -1]"]
    pub children: *mut *mut hwloc_obj,
    #[doc = "< \\brief First normal child"]
    pub first_child: *mut hwloc_obj,
    #[doc = "< \\brief Last normal child"]
    pub last_child: *mut hwloc_obj,
    #[doc = "< \\brief Set if the subtree of normal objects below this object is symmetric,"]
    #[doc = " which means all normal children and their children have identical subtrees."]
    #[doc = ""]
    #[doc = " Memory, I/O and Misc children are ignored."]
    #[doc = ""]
    #[doc = " If set in the topology root object, lstopo may export the topology"]
    #[doc = " as a synthetic string."]
    pub symmetric_subtree: ::std::os::raw::c_int,
    #[doc = "< \\brief Number of Memory children."]
    #[doc = " These children are listed in \\p memory_first_child."]
    pub memory_arity: ::std::os::raw::c_uint,
    #[doc = "< \\brief First Memory child."]
    #[doc = " NUMA nodes and Memory-side caches are listed here"]
    #[doc = " (\\p memory_arity and \\p memory_first_child)"]
    #[doc = " instead of in the normal children list."]
    #[doc = " See also hwloc_obj_type_is_memory()."]
    #[doc = ""]
    #[doc = " A memory hierarchy starts from a normal CPU-side object"]
    #[doc = " (e.g. Package) and ends with NUMA nodes as leaves."]
    #[doc = " There might exist some memory-side caches between them"]
    #[doc = " in the middle of the memory subtree."]
    pub memory_first_child: *mut hwloc_obj,
    #[doc = "< \\brief Number of I/O children."]
    #[doc = " These children are listed in \\p io_first_child."]
    pub io_arity: ::std::os::raw::c_uint,
    #[doc = "< \\brief First I/O child."]
    #[doc = " Bridges, PCI and OS devices are listed here (\\p io_arity and \\p io_first_child)"]
    #[doc = " instead of in the normal children list."]
    #[doc = " See also hwloc_obj_type_is_io()."]
    pub io_first_child: *mut hwloc_obj,
    #[doc = "< \\brief Number of Misc children."]
    #[doc = " These children are listed in \\p misc_first_child."]
    pub misc_arity: ::std::os::raw::c_uint,
    #[doc = "< \\brief First Misc child."]
    #[doc = " Misc objects are listed here (\\p misc_arity and \\p misc_first_child)"]
    #[doc = " instead of in the normal children list."]
    pub misc_first_child: *mut hwloc_obj,
    #[doc = "< \\brief CPUs covered by this object"]
    #[doc = ""]
    #[doc = " This is the set of CPUs for which there are PU objects in the topology"]
    #[doc = " under this object, i.e. which are known to be physically contained in this"]
    #[doc = " object and known how (the children path between this object and the PU"]
    #[doc = " objects)."]
    #[doc = ""]
    #[doc = " If the ::HWLOC_TOPOLOGY_FLAG_INCLUDE_DISALLOWED configuration flag is set,"]
    #[doc = " some of these CPUs may be online but not allowed for binding,"]
    #[doc = " see hwloc_topology_get_allowed_cpuset()."]
    #[doc = ""]
    #[doc = " \\note All objects have non-NULL CPU and node sets except Misc and I/O objects."]
    #[doc = ""]
    #[doc = " \\note Its value must not be changed, hwloc_bitmap_dup() must be used instead."]
    pub cpuset: hwloc_cpuset_t,
    #[doc = "< \\brief The complete CPU set of processors of this object,"]
    #[doc = ""]
    #[doc = " This may include not only the same as the cpuset field, but also some CPUs for"]
    #[doc = " which topology information is unknown or incomplete, some offlines CPUs, and"]
    #[doc = " the CPUs that are ignored when the ::HWLOC_TOPOLOGY_FLAG_INCLUDE_DISALLOWED flag"]
    #[doc = " is not set."]
    #[doc = " Thus no corresponding PU object may be found in the topology, because the"]
    #[doc = " precise position is undefined. It is however known that it would be somewhere"]
    #[doc = " under this object."]
    #[doc = ""]
    #[doc = " \\note Its value must not be changed, hwloc_bitmap_dup() must be used instead."]
    pub complete_cpuset: hwloc_cpuset_t,
    #[doc = "< \\brief NUMA nodes covered by this object or containing this object"]
    #[doc = ""]
    #[doc = " This is the set of NUMA nodes for which there are NUMA node objects in the"]
    #[doc = " topology under or above this object, i.e. which are known to be physically"]
    #[doc = " contained in this object or containing it and known how (the children path"]
    #[doc = " between this object and the NUMA node objects)."]
    #[doc = ""]
    #[doc = " In the end, these nodes are those that are close to the current object."]
    #[doc = " Function hwloc_get_local_numanode_objs() may be used to list those NUMA"]
    #[doc = " nodes more precisely."]
    #[doc = ""]
    #[doc = " If the ::HWLOC_TOPOLOGY_FLAG_INCLUDE_DISALLOWED configuration flag is set,"]
    #[doc = " some of these nodes may be online but not allowed for allocation,"]
    #[doc = " see hwloc_topology_get_allowed_nodeset()."]
    #[doc = ""]
    #[doc = " If there are no NUMA nodes in the machine, all the memory is close to this"]
    #[doc = " object, so only the first bit may be set in \\p nodeset."]
    #[doc = ""]
    #[doc = " \\note All objects have non-NULL CPU and node sets except Misc and I/O objects."]
    #[doc = ""]
    #[doc = " \\note Its value must not be changed, hwloc_bitmap_dup() must be used instead."]
    pub nodeset: hwloc_nodeset_t,
    #[doc = "< \\brief The complete NUMA node set of this object,"]
    #[doc = ""]
    #[doc = " This may include not only the same as the nodeset field, but also some NUMA"]
    #[doc = " nodes for which topology information is unknown or incomplete, some offlines"]
    #[doc = " nodes, and the nodes that are ignored when the ::HWLOC_TOPOLOGY_FLAG_INCLUDE_DISALLOWED"]
    #[doc = " flag is not set."]
    #[doc = " Thus no corresponding NUMA node object may be found in the topology, because the"]
    #[doc = " precise position is undefined. It is however known that it would be"]
    #[doc = " somewhere under this object."]
    #[doc = ""]
    #[doc = " If there are no NUMA nodes in the machine, all the memory is close to this"]
    #[doc = " object, so only the first bit is set in \\p complete_nodeset."]
    #[doc = ""]
    #[doc = " \\note Its value must not be changed, hwloc_bitmap_dup() must be used instead."]
    pub complete_nodeset: hwloc_nodeset_t,
    #[doc = "< \\brief Array of stringified info type=name."]
    pub infos: *mut hwloc_info_s,
    #[doc = "< \\brief Size of infos array."]
    pub infos_count: ::std::os::raw::c_uint,
    #[doc = "< \\brief Application-given private data pointer,"]
    #[doc = " initialized to \\c NULL, use it as you wish."]
    #[doc = " See hwloc_topology_set_userdata_export_callback() in hwloc/export.h"]
    #[doc = " if you wish to export this field to XML."]
    pub userdata: *mut ::std::os::raw::c_void,
    #[doc = "< \\brief Global persistent index."]
    #[doc = " Generated by hwloc, unique across the topology (contrary to os_index)"]
    #[doc = " and persistent across topology changes (contrary to logical_index)."]
    #[doc = " Mostly used internally, but could also be used by application to identify objects."]
    pub gp_index: hwloc_uint64_t,
}
#[test]
fn bindgen_test_layout_hwloc_obj() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_obj>(),
        248usize,
        concat!("Size of: ", stringify!(hwloc_obj))
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_obj>(),
        8usize,
        concat!("Alignment of ", stringify!(hwloc_obj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).subtype as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(subtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).os_index as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(os_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).name as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).total_memory as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(total_memory)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).attr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(attr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).depth as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).logical_index as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(logical_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).next_cousin as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(next_cousin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).prev_cousin as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(prev_cousin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).parent as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).sibling_rank as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(sibling_rank)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).next_sibling as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(next_sibling)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).prev_sibling as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(prev_sibling)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).arity as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(arity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).children as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(children)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).first_child as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(first_child)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).last_child as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(last_child)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).symmetric_subtree as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(symmetric_subtree)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).memory_arity as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(memory_arity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).memory_first_child as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(memory_first_child)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).io_arity as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(io_arity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).io_first_child as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(io_first_child)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).misc_arity as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(misc_arity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).misc_first_child as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(misc_first_child)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).cpuset as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(cpuset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).complete_cpuset as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(complete_cpuset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).nodeset as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(nodeset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).complete_nodeset as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(complete_nodeset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).infos as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(infos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).infos_count as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(infos_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).userdata as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(userdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).gp_index as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(gp_index)
        )
    );
}
#[doc = " \\brief Convenience typedef; a pointer to a struct hwloc_obj."]
pub type hwloc_obj_t = *mut hwloc_obj;
#[doc = " \\defgroup hwlocality_objects Object Structure and Attributes"]
#[doc = " @{"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union hwloc_obj_attr_u {
    pub numanode: hwloc_obj_attr_u_hwloc_numanode_attr_s,
    pub cache: hwloc_obj_attr_u_hwloc_cache_attr_s,
    pub group: hwloc_obj_attr_u_hwloc_group_attr_s,
    pub pcidev: hwloc_obj_attr_u_hwloc_pcidev_attr_s,
    pub bridge: hwloc_obj_attr_u_hwloc_bridge_attr_s,
    pub osdev: hwloc_obj_attr_u_hwloc_osdev_attr_s,
}
#[doc = " \\brief NUMA node-specific Object Attributes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hwloc_obj_attr_u_hwloc_numanode_attr_s {
    #[doc = "< \\brief Local memory (in bytes)"]
    pub local_memory: hwloc_uint64_t,
    #[doc = "< \\brief Size of array \\p page_types"]
    pub page_types_len: ::std::os::raw::c_uint,
    pub page_types: *mut hwloc_obj_attr_u_hwloc_numanode_attr_s_hwloc_memory_page_type_s,
}
#[doc = " \\brief Array of local memory page types, \\c NULL if no local memory and \\p page_types is 0."]
#[doc = ""]
#[doc = " The array is sorted by increasing \\p size fields."]
#[doc = " It contains \\p page_types_len slots."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hwloc_obj_attr_u_hwloc_numanode_attr_s_hwloc_memory_page_type_s {
    #[doc = "< \\brief Size of pages"]
    pub size: hwloc_uint64_t,
    #[doc = "< \\brief Number of pages of this size"]
    pub count: hwloc_uint64_t,
}
#[test]
fn bindgen_test_layout_hwloc_obj_attr_u_hwloc_numanode_attr_s_hwloc_memory_page_type_s() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_obj_attr_u_hwloc_numanode_attr_s_hwloc_memory_page_type_s>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(hwloc_obj_attr_u_hwloc_numanode_attr_s_hwloc_memory_page_type_s)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_obj_attr_u_hwloc_numanode_attr_s_hwloc_memory_page_type_s>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hwloc_obj_attr_u_hwloc_numanode_attr_s_hwloc_memory_page_type_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_numanode_attr_s_hwloc_memory_page_type_s>(
            )))
            .size as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_numanode_attr_s_hwloc_memory_page_type_s),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_numanode_attr_s_hwloc_memory_page_type_s>(
            )))
            .count as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_numanode_attr_s_hwloc_memory_page_type_s),
            "::",
            stringify!(count)
        )
    );
}
#[test]
fn bindgen_test_layout_hwloc_obj_attr_u_hwloc_numanode_attr_s() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_obj_attr_u_hwloc_numanode_attr_s>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(hwloc_obj_attr_u_hwloc_numanode_attr_s)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_obj_attr_u_hwloc_numanode_attr_s>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hwloc_obj_attr_u_hwloc_numanode_attr_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_numanode_attr_s>())).local_memory
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_numanode_attr_s),
            "::",
            stringify!(local_memory)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_numanode_attr_s>())).page_types_len
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_numanode_attr_s),
            "::",
            stringify!(page_types_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_numanode_attr_s>())).page_types
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_numanode_attr_s),
            "::",
            stringify!(page_types)
        )
    );
}
#[doc = " \\brief Cache-specific Object Attributes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hwloc_obj_attr_u_hwloc_cache_attr_s {
    #[doc = "< \\brief Size of cache in bytes"]
    pub size: hwloc_uint64_t,
    #[doc = "< \\brief Depth of cache (e.g., L1, L2, ...etc.)"]
    pub depth: ::std::os::raw::c_uint,
    #[doc = "< \\brief Cache-line size in bytes. 0 if unknown"]
    pub linesize: ::std::os::raw::c_uint,
    #[doc = "< \\brief Ways of associativity,"]
    #[doc = "  -1 if fully associative, 0 if unknown"]
    pub associativity: ::std::os::raw::c_int,
    #[doc = "< \\brief Cache type"]
    pub type_: hwloc_obj_cache_type_t,
}
#[test]
fn bindgen_test_layout_hwloc_obj_attr_u_hwloc_cache_attr_s() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_obj_attr_u_hwloc_cache_attr_s>(),
        24usize,
        concat!("Size of: ", stringify!(hwloc_obj_attr_u_hwloc_cache_attr_s))
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_obj_attr_u_hwloc_cache_attr_s>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hwloc_obj_attr_u_hwloc_cache_attr_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_cache_attr_s>())).size as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_cache_attr_s),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_cache_attr_s>())).depth as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_cache_attr_s),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_cache_attr_s>())).linesize as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_cache_attr_s),
            "::",
            stringify!(linesize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_cache_attr_s>())).associativity
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_cache_attr_s),
            "::",
            stringify!(associativity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_cache_attr_s>())).type_ as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_cache_attr_s),
            "::",
            stringify!(type_)
        )
    );
}
#[doc = " \\brief Group-specific Object Attributes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hwloc_obj_attr_u_hwloc_group_attr_s {
    #[doc = "< \\brief Depth of group object."]
    #[doc = "   It may change if intermediate Group objects are added."]
    pub depth: ::std::os::raw::c_uint,
    #[doc = "< \\brief Internally-used kind of group."]
    pub kind: ::std::os::raw::c_uint,
    #[doc = "< \\brief Internally-used subkind to distinguish different levels of groups with same kind"]
    pub subkind: ::std::os::raw::c_uint,
    #[doc = "< \\brief Flag preventing groups from being automatically merged with identical parent or children."]
    pub dont_merge: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_hwloc_obj_attr_u_hwloc_group_attr_s() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_obj_attr_u_hwloc_group_attr_s>(),
        16usize,
        concat!("Size of: ", stringify!(hwloc_obj_attr_u_hwloc_group_attr_s))
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_obj_attr_u_hwloc_group_attr_s>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(hwloc_obj_attr_u_hwloc_group_attr_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_group_attr_s>())).depth as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_group_attr_s),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_group_attr_s>())).kind as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_group_attr_s),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_group_attr_s>())).subkind as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_group_attr_s),
            "::",
            stringify!(subkind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_group_attr_s>())).dont_merge as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_group_attr_s),
            "::",
            stringify!(dont_merge)
        )
    );
}
#[doc = " \\brief PCI Device specific Object Attributes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hwloc_obj_attr_u_hwloc_pcidev_attr_s {
    pub domain: ::std::os::raw::c_ushort,
    pub bus: ::std::os::raw::c_uchar,
    pub dev: ::std::os::raw::c_uchar,
    pub func: ::std::os::raw::c_uchar,
    pub class_id: ::std::os::raw::c_ushort,
    pub vendor_id: ::std::os::raw::c_ushort,
    pub device_id: ::std::os::raw::c_ushort,
    pub subvendor_id: ::std::os::raw::c_ushort,
    pub subdevice_id: ::std::os::raw::c_ushort,
    pub revision: ::std::os::raw::c_uchar,
    pub linkspeed: f32,
}
#[test]
fn bindgen_test_layout_hwloc_obj_attr_u_hwloc_pcidev_attr_s() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_obj_attr_u_hwloc_pcidev_attr_s>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(hwloc_obj_attr_u_hwloc_pcidev_attr_s)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_obj_attr_u_hwloc_pcidev_attr_s>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(hwloc_obj_attr_u_hwloc_pcidev_attr_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_pcidev_attr_s>())).domain as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_pcidev_attr_s),
            "::",
            stringify!(domain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_pcidev_attr_s>())).bus as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_pcidev_attr_s),
            "::",
            stringify!(bus)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_pcidev_attr_s>())).dev as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_pcidev_attr_s),
            "::",
            stringify!(dev)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_pcidev_attr_s>())).func as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_pcidev_attr_s),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_pcidev_attr_s>())).class_id as *const _
                as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_pcidev_attr_s),
            "::",
            stringify!(class_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_pcidev_attr_s>())).vendor_id as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_pcidev_attr_s),
            "::",
            stringify!(vendor_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_pcidev_attr_s>())).device_id as *const _
                as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_pcidev_attr_s),
            "::",
            stringify!(device_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_pcidev_attr_s>())).subvendor_id
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_pcidev_attr_s),
            "::",
            stringify!(subvendor_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_pcidev_attr_s>())).subdevice_id
                as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_pcidev_attr_s),
            "::",
            stringify!(subdevice_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_pcidev_attr_s>())).revision as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_pcidev_attr_s),
            "::",
            stringify!(revision)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_pcidev_attr_s>())).linkspeed as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_pcidev_attr_s),
            "::",
            stringify!(linkspeed)
        )
    );
}
#[doc = " \\brief Bridge specific Object Attributes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hwloc_obj_attr_u_hwloc_bridge_attr_s {
    pub upstream: hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_1,
    pub upstream_type: hwloc_obj_bridge_type_t,
    pub downstream: hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_2,
    pub downstream_type: hwloc_obj_bridge_type_t,
    pub depth: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_1 {
    pub pci: hwloc_obj_attr_u_hwloc_pcidev_attr_s,
}
#[test]
fn bindgen_test_layout_hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_1>())).pci
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_1),
            "::",
            stringify!(pci)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_2 {
    pub pci: hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_2__bindgen_ty_1 {
    pub domain: ::std::os::raw::c_ushort,
    pub secondary_bus: ::std::os::raw::c_uchar,
    pub subordinate_bus: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_2__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            & (* (:: std :: ptr :: null :: < hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_2__bindgen_ty_1 > ())) . domain as * const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(domain)
        )
    );
    assert_eq!(
        unsafe {
            & (* (:: std :: ptr :: null :: < hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_2__bindgen_ty_1 > ())) . secondary_bus as * const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(secondary_bus)
        )
    );
    assert_eq!(
        unsafe {
            & (* (:: std :: ptr :: null :: < hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_2__bindgen_ty_1 > ())) . subordinate_bus as * const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(subordinate_bus)
        )
    );
}
#[test]
fn bindgen_test_layout_hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_2>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_2>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_2>())).pci
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_2),
            "::",
            stringify!(pci)
        )
    );
}
#[test]
fn bindgen_test_layout_hwloc_obj_attr_u_hwloc_bridge_attr_s() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_obj_attr_u_hwloc_bridge_attr_s>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(hwloc_obj_attr_u_hwloc_bridge_attr_s)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_obj_attr_u_hwloc_bridge_attr_s>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(hwloc_obj_attr_u_hwloc_bridge_attr_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_bridge_attr_s>())).upstream as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_bridge_attr_s),
            "::",
            stringify!(upstream)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_bridge_attr_s>())).upstream_type
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_bridge_attr_s),
            "::",
            stringify!(upstream_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_bridge_attr_s>())).downstream as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_bridge_attr_s),
            "::",
            stringify!(downstream)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_bridge_attr_s>())).downstream_type
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_bridge_attr_s),
            "::",
            stringify!(downstream_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_bridge_attr_s>())).depth as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_bridge_attr_s),
            "::",
            stringify!(depth)
        )
    );
}
#[doc = " \\brief OS Device specific Object Attributes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hwloc_obj_attr_u_hwloc_osdev_attr_s {
    pub type_: hwloc_obj_osdev_type_t,
}
#[test]
fn bindgen_test_layout_hwloc_obj_attr_u_hwloc_osdev_attr_s() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_obj_attr_u_hwloc_osdev_attr_s>(),
        4usize,
        concat!("Size of: ", stringify!(hwloc_obj_attr_u_hwloc_osdev_attr_s))
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_obj_attr_u_hwloc_osdev_attr_s>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(hwloc_obj_attr_u_hwloc_osdev_attr_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_osdev_attr_s>())).type_ as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_osdev_attr_s),
            "::",
            stringify!(type_)
        )
    );
}
#[test]
fn bindgen_test_layout_hwloc_obj_attr_u() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_obj_attr_u>(),
        40usize,
        concat!("Size of: ", stringify!(hwloc_obj_attr_u))
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_obj_attr_u>(),
        8usize,
        concat!("Alignment of ", stringify!(hwloc_obj_attr_u))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj_attr_u>())).numanode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u),
            "::",
            stringify!(numanode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj_attr_u>())).cache as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u),
            "::",
            stringify!(cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj_attr_u>())).group as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u),
            "::",
            stringify!(group)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj_attr_u>())).pcidev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u),
            "::",
            stringify!(pcidev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj_attr_u>())).bridge as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u),
            "::",
            stringify!(bridge)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj_attr_u>())).osdev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u),
            "::",
            stringify!(osdev)
        )
    );
}
#[doc = " \\brief Object info"]
#[doc = ""]
#[doc = " \\sa hwlocality_info_attr"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hwloc_info_s {
    #[doc = "< \\brief Info name"]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = "< \\brief Info value"]
    pub value: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_hwloc_info_s() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_info_s>(),
        16usize,
        concat!("Size of: ", stringify!(hwloc_info_s))
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_info_s>(),
        8usize,
        concat!("Alignment of ", stringify!(hwloc_info_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_info_s>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_info_s),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_info_s>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_info_s),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " \\defgroup hwlocality_creation Topology Creation and Destruction"]
#[doc = " @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hwloc_topology {
    _unused: [u8; 0],
}
#[doc = " \\brief Topology context"]
#[doc = ""]
#[doc = " To be initialized with hwloc_topology_init() and built with hwloc_topology_load()."]
pub type hwloc_topology_t = *mut hwloc_topology;
extern "C" {
    #[doc = " \\brief Allocate a topology context."]
    #[doc = ""]
    #[doc = " \\param[out] topologyp is assigned a pointer to the new allocated context."]
    #[doc = ""]
    #[doc = " \\return 0 on success, -1 on error."]
    pub fn hwloc_topology_init(topologyp: *mut hwloc_topology_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Build the actual topology"]
    #[doc = ""]
    #[doc = " Build the actual topology once initialized with hwloc_topology_init() and"]
    #[doc = " tuned with \\ref hwlocality_configuration and \\ref hwlocality_setsource routines."]
    #[doc = " No other routine may be called earlier using this topology context."]
    #[doc = ""]
    #[doc = " \\param topology is the topology to be loaded with objects."]
    #[doc = ""]
    #[doc = " \\return 0 on success, -1 on error."]
    #[doc = ""]
    #[doc = " \\note On failure, the topology is reinitialized. It should be either"]
    #[doc = " destroyed with hwloc_topology_destroy() or configured and loaded again."]
    #[doc = ""]
    #[doc = " \\note This function may be called only once per topology."]
    #[doc = ""]
    #[doc = " \\note The binding of the current thread or process may temporarily change"]
    #[doc = " during this call but it will be restored before it returns."]
    #[doc = ""]
    #[doc = " \\sa hwlocality_configuration and hwlocality_setsource"]
    pub fn hwloc_topology_load(topology: hwloc_topology_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Terminate and free a topology context"]
    #[doc = ""]
    #[doc = " \\param topology is the topology to be freed"]
    pub fn hwloc_topology_destroy(topology: hwloc_topology_t);
}
extern "C" {
    #[doc = " \\brief Duplicate a topology."]
    #[doc = ""]
    #[doc = " The entire topology structure as well as its objects"]
    #[doc = " are duplicated into a new one."]
    #[doc = ""]
    #[doc = " This is useful for keeping a backup while modifying a topology."]
    #[doc = ""]
    #[doc = " \\note Object userdata is not duplicated since hwloc does not know what it point to."]
    #[doc = " The objects of both old and new topologies will point to the same userdata."]
    pub fn hwloc_topology_dup(
        newtopology: *mut hwloc_topology_t,
        oldtopology: hwloc_topology_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Verify that the topology is compatible with the current hwloc library."]
    #[doc = ""]
    #[doc = " This is useful when using the same topology structure (in memory)"]
    #[doc = " in different libraries that may use different hwloc installations"]
    #[doc = " (for instance if one library embeds a specific version of hwloc,"]
    #[doc = " while another library uses a default system-wide hwloc installation)."]
    #[doc = ""]
    #[doc = " If all libraries/programs use the same hwloc installation, this function"]
    #[doc = " always returns success."]
    #[doc = ""]
    #[doc = " \\return \\c 0 on success."]
    #[doc = ""]
    #[doc = " \\return \\c -1 with \\p errno set to \\c EINVAL if incompatible."]
    #[doc = ""]
    #[doc = " \\note If sharing between processes with hwloc_shmem_topology_write(),"]
    #[doc = " the relevant check is already performed inside hwloc_shmem_topology_adopt()."]
    pub fn hwloc_topology_abi_check(topology: hwloc_topology_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Run internal checks on a topology structure"]
    #[doc = ""]
    #[doc = " The program aborts if an inconsistency is detected in the given topology."]
    #[doc = ""]
    #[doc = " \\param topology is the topology to be checked"]
    #[doc = ""]
    #[doc = " \\note This routine is only useful to developers."]
    #[doc = ""]
    #[doc = " \\note The input topology should have been previously loaded with"]
    #[doc = " hwloc_topology_load()."]
    pub fn hwloc_topology_check(topology: hwloc_topology_t);
}
extern "C" {
    #[doc = " \\brief Get the depth of the hierarchical tree of objects."]
    #[doc = ""]
    #[doc = " This is the depth of ::HWLOC_OBJ_PU objects plus one."]
    #[doc = ""]
    #[doc = " \\note NUMA nodes, I/O and Misc objects are ignored when computing"]
    #[doc = " the depth of the tree (they are placed on special levels)."]
    pub fn hwloc_topology_get_depth(topology: hwloc_topology_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Returns the depth of objects of type \\p type."]
    #[doc = ""]
    #[doc = " If no object of this type is present on the underlying architecture, or if"]
    #[doc = " the OS doesn't provide this kind of information, the function returns"]
    #[doc = " ::HWLOC_TYPE_DEPTH_UNKNOWN."]
    #[doc = ""]
    #[doc = " If type is absent but a similar type is acceptable, see also"]
    #[doc = " hwloc_get_type_or_below_depth() and hwloc_get_type_or_above_depth()."]
    #[doc = ""]
    #[doc = " If ::HWLOC_OBJ_GROUP is given, the function may return ::HWLOC_TYPE_DEPTH_MULTIPLE"]
    #[doc = " if multiple levels of Groups exist."]
    #[doc = ""]
    #[doc = " If a NUMA node, I/O or Misc object type is given, the function returns a virtual"]
    #[doc = " value because these objects are stored in special levels that are not CPU-related."]
    #[doc = " This virtual depth may be passed to other hwloc functions such as"]
    #[doc = " hwloc_get_obj_by_depth() but it should not be considered as an actual"]
    #[doc = " depth by the application. In particular, it should not be compared with"]
    #[doc = " any other object depth or with the entire topology depth."]
    #[doc = " \\sa hwloc_get_memory_parents_depth()."]
    #[doc = ""]
    #[doc = " \\sa hwloc_type_sscanf_as_depth() for returning the depth of objects"]
    #[doc = " whose type is given as a string."]
    pub fn hwloc_get_type_depth(
        topology: hwloc_topology_t,
        type_: hwloc_obj_type_t,
    ) -> ::std::os::raw::c_int;
}
#[doc = "< \\brief No object of given type exists in the topology. \\hideinitializer"]
pub const hwloc_get_type_depth_e_HWLOC_TYPE_DEPTH_UNKNOWN: hwloc_get_type_depth_e = -1;
#[doc = "< \\brief Objects of given type exist at different depth in the topology (only for Groups). \\hideinitializer"]
pub const hwloc_get_type_depth_e_HWLOC_TYPE_DEPTH_MULTIPLE: hwloc_get_type_depth_e = -2;
#[doc = "< \\brief Virtual depth for NUMA nodes. \\hideinitializer"]
pub const hwloc_get_type_depth_e_HWLOC_TYPE_DEPTH_NUMANODE: hwloc_get_type_depth_e = -3;
#[doc = "< \\brief Virtual depth for bridge object level. \\hideinitializer"]
pub const hwloc_get_type_depth_e_HWLOC_TYPE_DEPTH_BRIDGE: hwloc_get_type_depth_e = -4;
#[doc = "< \\brief Virtual depth for PCI device object level. \\hideinitializer"]
pub const hwloc_get_type_depth_e_HWLOC_TYPE_DEPTH_PCI_DEVICE: hwloc_get_type_depth_e = -5;
#[doc = "< \\brief Virtual depth for software device object level. \\hideinitializer"]
pub const hwloc_get_type_depth_e_HWLOC_TYPE_DEPTH_OS_DEVICE: hwloc_get_type_depth_e = -6;
#[doc = "< \\brief Virtual depth for Misc object. \\hideinitializer"]
pub const hwloc_get_type_depth_e_HWLOC_TYPE_DEPTH_MISC: hwloc_get_type_depth_e = -7;
#[doc = "< \\brief Virtual depth for MemCache object. \\hideinitializer"]
pub const hwloc_get_type_depth_e_HWLOC_TYPE_DEPTH_MEMCACHE: hwloc_get_type_depth_e = -8;
pub type hwloc_get_type_depth_e = ::std::os::raw::c_int;
extern "C" {
    #[doc = " \\brief Return the depth of parents where memory objects are attached."]
    #[doc = ""]
    #[doc = " Memory objects have virtual negative depths because they are not part of"]
    #[doc = " the main CPU-side hierarchy of objects. This depth should not be compared"]
    #[doc = " with other level depths."]
    #[doc = ""]
    #[doc = " If all Memory objects are attached to Normal parents at the same depth,"]
    #[doc = " this parent depth may be compared to other as usual, for instance"]
    #[doc = " for knowing whether NUMA nodes is attached above or below Packages."]
    #[doc = ""]
    #[doc = " \\return The depth of Normal parents of all memory children"]
    #[doc = " if all these parents have the same depth. For instance the depth of"]
    #[doc = " the Package level if all NUMA nodes are attached to Package objects."]
    #[doc = ""]
    #[doc = " \\return ::HWLOC_TYPE_DEPTH_MULTIPLE if Normal parents of all"]
    #[doc = " memory children do not have the same depth. For instance if some"]
    #[doc = " NUMA nodes are attached to Packages while others are attached to"]
    #[doc = " Groups."]
    pub fn hwloc_get_memory_parents_depth(topology: hwloc_topology_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Returns the type of objects at depth \\p depth."]
    #[doc = ""]
    #[doc = " \\p depth should between 0 and hwloc_topology_get_depth()-1,"]
    #[doc = " or a virtual depth such as ::HWLOC_TYPE_DEPTH_NUMANODE."]
    #[doc = ""]
    #[doc = " \\return (hwloc_obj_type_t)-1 if depth \\p depth does not exist."]
    pub fn hwloc_get_depth_type(
        topology: hwloc_topology_t,
        depth: ::std::os::raw::c_int,
    ) -> hwloc_obj_type_t;
}
extern "C" {
    #[doc = " \\brief Returns the width of level at depth \\p depth."]
    pub fn hwloc_get_nbobjs_by_depth(
        topology: hwloc_topology_t,
        depth: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " \\brief Returns the topology object at logical index \\p idx from depth \\p depth"]
    pub fn hwloc_get_obj_by_depth(
        topology: hwloc_topology_t,
        depth: ::std::os::raw::c_int,
        idx: ::std::os::raw::c_uint,
    ) -> hwloc_obj_t;
}
extern "C" {
    #[doc = " \\brief Return a constant stringified object type."]
    #[doc = ""]
    #[doc = " This function is the basic way to convert a generic type into a string."]
    #[doc = " The output string may be parsed back by hwloc_type_sscanf()."]
    #[doc = ""]
    #[doc = " hwloc_obj_type_snprintf() may return a more precise output for a specific"]
    #[doc = " object, but it requires the caller to provide the output buffer."]
    pub fn hwloc_obj_type_string(type_: hwloc_obj_type_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " \\brief Stringify the type of a given topology object into a human-readable form."]
    #[doc = ""]
    #[doc = " Contrary to hwloc_obj_type_string(), this function includes object-specific"]
    #[doc = " attributes (such as the Group depth, the Bridge type, or OS device type)"]
    #[doc = " in the output, and it requires the caller to provide the output buffer."]
    #[doc = ""]
    #[doc = " The output is guaranteed to be the same for all objects of a same topology level."]
    #[doc = ""]
    #[doc = " If \\p verbose is 1, longer type names are used, e.g. L1Cache instead of L1."]
    #[doc = ""]
    #[doc = " The output string may be parsed back by hwloc_type_sscanf()."]
    #[doc = ""]
    #[doc = " If \\p size is 0, \\p string may safely be \\c NULL."]
    #[doc = ""]
    #[doc = " \\return the number of character that were actually written if not truncating,"]
    #[doc = " or that would have been written (not including the ending \\\\0)."]
    pub fn hwloc_obj_type_snprintf(
        string: *mut ::std::os::raw::c_char,
        size: size_t,
        obj: hwloc_obj_t,
        verbose: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Stringify the attributes of a given topology object into a human-readable form."]
    #[doc = ""]
    #[doc = " Attribute values are separated by \\p separator."]
    #[doc = ""]
    #[doc = " Only the major attributes are printed in non-verbose mode."]
    #[doc = ""]
    #[doc = " If \\p size is 0, \\p string may safely be \\c NULL."]
    #[doc = ""]
    #[doc = " \\return the number of character that were actually written if not truncating,"]
    #[doc = " or that would have been written (not including the ending \\\\0)."]
    pub fn hwloc_obj_attr_snprintf(
        string: *mut ::std::os::raw::c_char,
        size: size_t,
        obj: hwloc_obj_t,
        separator: *const ::std::os::raw::c_char,
        verbose: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Return an object type and attributes from a type string."]
    #[doc = ""]
    #[doc = " Convert strings such as \"Package\" or \"L1iCache\" into the corresponding types."]
    #[doc = " Matching is case-insensitive, and only the first letters are actually"]
    #[doc = " required to match."]
    #[doc = ""]
    #[doc = " The matched object type is set in \\p typep (which cannot be \\c NULL)."]
    #[doc = ""]
    #[doc = " Type-specific attributes, for instance Cache type, Cache depth, Group depth,"]
    #[doc = " Bridge type or OS Device type may be returned in \\p attrp."]
    #[doc = " Attributes that are not specified in the string (for instance \"Group\""]
    #[doc = " without a depth, or \"L2Cache\" without a cache type) are set to -1."]
    #[doc = ""]
    #[doc = " \\p attrp is only filled if not \\c NULL and if its size specified in \\p attrsize"]
    #[doc = " is large enough. It should be at least as large as union hwloc_obj_attr_u."]
    #[doc = ""]
    #[doc = " \\return 0 if a type was correctly identified, otherwise -1."]
    #[doc = ""]
    #[doc = " \\note This function is guaranteed to match any string returned by"]
    #[doc = " hwloc_obj_type_string() or hwloc_obj_type_snprintf()."]
    #[doc = ""]
    #[doc = " \\note This is an extended version of the now deprecated hwloc_obj_type_sscanf()."]
    pub fn hwloc_type_sscanf(
        string: *const ::std::os::raw::c_char,
        typep: *mut hwloc_obj_type_t,
        attrp: *mut hwloc_obj_attr_u,
        attrsize: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Return an object type and its level depth from a type string."]
    #[doc = ""]
    #[doc = " Convert strings such as \"Package\" or \"L1iCache\" into the corresponding types"]
    #[doc = " and return in \\p depthp the depth of the corresponding level in the"]
    #[doc = " topology \\p topology."]
    #[doc = ""]
    #[doc = " If no object of this type is present on the underlying architecture,"]
    #[doc = " ::HWLOC_TYPE_DEPTH_UNKNOWN is returned."]
    #[doc = ""]
    #[doc = " If multiple such levels exist (for instance if giving Group without any depth),"]
    #[doc = " the function may return ::HWLOC_TYPE_DEPTH_MULTIPLE instead."]
    #[doc = ""]
    #[doc = " The matched object type is set in \\p typep if \\p typep is non \\c NULL."]
    #[doc = ""]
    #[doc = " \\note This function is similar to hwloc_type_sscanf() followed"]
    #[doc = " by hwloc_get_type_depth() but it also automatically disambiguates"]
    #[doc = " multiple group levels etc."]
    #[doc = ""]
    #[doc = " \\note This function is guaranteed to match any string returned by"]
    #[doc = " hwloc_obj_type_string() or hwloc_obj_type_snprintf()."]
    pub fn hwloc_type_sscanf_as_depth(
        string: *const ::std::os::raw::c_char,
        typep: *mut hwloc_obj_type_t,
        topology: hwloc_topology_t,
        depthp: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Add the given info name and value pair to the given object."]
    #[doc = ""]
    #[doc = " The info is appended to the existing info array even if another key"]
    #[doc = " with the same name already exists."]
    #[doc = ""]
    #[doc = " The input strings are copied before being added in the object infos."]
    #[doc = ""]
    #[doc = " \\return \\c 0 on success, \\c -1 on error."]
    #[doc = ""]
    #[doc = " \\note This function may be used to enforce object colors in the lstopo"]
    #[doc = " graphical output by using \"lstopoStyle\" as a name and \"Background=#rrggbb\""]
    #[doc = " as a value. See CUSTOM COLORS in the lstopo(1) manpage for details."]
    #[doc = ""]
    #[doc = " \\note If \\p value contains some non-printable characters, they will"]
    #[doc = " be dropped when exporting to XML, see hwloc_topology_export_xml() in hwloc/export.h."]
    pub fn hwloc_obj_add_info(
        obj: hwloc_obj_t,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[doc = " \\brief Bind all threads of the current (possibly) multithreaded process."]
#[doc = " \\hideinitializer"]
pub const hwloc_cpubind_flags_t_HWLOC_CPUBIND_PROCESS: hwloc_cpubind_flags_t = 1;
#[doc = " \\brief Bind current thread of current process."]
#[doc = " \\hideinitializer"]
pub const hwloc_cpubind_flags_t_HWLOC_CPUBIND_THREAD: hwloc_cpubind_flags_t = 2;
#[doc = " \\brief Request for strict binding from the OS."]
#[doc = ""]
#[doc = " By default, when the designated CPUs are all busy while other"]
#[doc = " CPUs are idle, operating systems may execute the thread/process"]
#[doc = " on those other CPUs instead of the designated CPUs, to let them"]
#[doc = " progress anyway.  Strict binding means that the thread/process"]
#[doc = " will _never_ execute on other CPUs than the designated CPUs, even"]
#[doc = " when those are busy with other tasks and other CPUs are idle."]
#[doc = ""]
#[doc = " \\note Depending on the operating system, strict binding may not"]
#[doc = " be possible (e.g., the OS does not implement it) or not allowed"]
#[doc = " (e.g., for an administrative reasons), and the function will fail"]
#[doc = " in that case."]
#[doc = ""]
#[doc = " When retrieving the binding of a process, this flag checks"]
#[doc = " whether all its threads  actually have the same binding. If the"]
#[doc = " flag is not given, the binding of each thread will be"]
#[doc = " accumulated."]
#[doc = ""]
#[doc = " \\note This flag is meaningless when retrieving the binding of a"]
#[doc = " thread."]
#[doc = " \\hideinitializer"]
pub const hwloc_cpubind_flags_t_HWLOC_CPUBIND_STRICT: hwloc_cpubind_flags_t = 4;
#[doc = " \\brief Avoid any effect on memory binding"]
#[doc = ""]
#[doc = " On some operating systems, some CPU binding function would also"]
#[doc = " bind the memory on the corresponding NUMA node.  It is often not"]
#[doc = " a problem for the application, but if it is, setting this flag"]
#[doc = " will make hwloc avoid using OS functions that would also bind"]
#[doc = " memory.  This will however reduce the support of CPU bindings,"]
#[doc = " i.e. potentially return -1 with errno set to ENOSYS in some"]
#[doc = " cases."]
#[doc = ""]
#[doc = " This flag is only meaningful when used with functions that set"]
#[doc = " the CPU binding.  It is ignored when used with functions that get"]
#[doc = " CPU binding information."]
#[doc = " \\hideinitializer"]
pub const hwloc_cpubind_flags_t_HWLOC_CPUBIND_NOMEMBIND: hwloc_cpubind_flags_t = 8;
#[doc = " \\brief Process/Thread binding flags."]
#[doc = ""]
#[doc = " These bit flags can be used to refine the binding policy."]
#[doc = ""]
#[doc = " The default (0) is to bind the current process, assumed to be"]
#[doc = " single-threaded, in a non-strict way.  This is the most portable"]
#[doc = " way to bind as all operating systems usually provide it."]
#[doc = ""]
#[doc = " \\note Not all systems support all kinds of binding.  See the"]
#[doc = " \"Detailed Description\" section of \\ref hwlocality_cpubinding for a"]
#[doc = " description of errors that can occur."]
pub type hwloc_cpubind_flags_t = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " \\brief Bind current process or thread on CPUs given in physical bitmap \\p set."]
    #[doc = ""]
    #[doc = " \\return -1 with errno set to ENOSYS if the action is not supported"]
    #[doc = " \\return -1 with errno set to EXDEV if the binding cannot be enforced"]
    pub fn hwloc_set_cpubind(
        topology: hwloc_topology_t,
        set: hwloc_const_cpuset_t,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get current process or thread binding."]
    #[doc = ""]
    #[doc = " The CPU-set \\p set (previously allocated by the caller)"]
    #[doc = " is filled with the list of PUs which the process or"]
    #[doc = " thread (according to \\e flags) was last bound to."]
    pub fn hwloc_get_cpubind(
        topology: hwloc_topology_t,
        set: hwloc_cpuset_t,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Bind a process \\p pid on CPUs given in physical bitmap \\p set."]
    #[doc = ""]
    #[doc = " \\note \\p hwloc_pid_t is \\p pid_t on Unix platforms,"]
    #[doc = " and \\p HANDLE on native Windows platforms."]
    #[doc = ""]
    #[doc = " \\note As a special case on Linux, if a tid (thread ID) is supplied"]
    #[doc = " instead of a pid (process ID) and ::HWLOC_CPUBIND_THREAD is passed in flags,"]
    #[doc = " the binding is applied to that specific thread."]
    #[doc = ""]
    #[doc = " \\note On non-Linux systems, ::HWLOC_CPUBIND_THREAD can not be used in \\p flags."]
    pub fn hwloc_set_proc_cpubind(
        topology: hwloc_topology_t,
        pid: pid_t,
        set: hwloc_const_cpuset_t,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get the current physical binding of process \\p pid."]
    #[doc = ""]
    #[doc = " The CPU-set \\p set (previously allocated by the caller)"]
    #[doc = " is filled with the list of PUs which the process"]
    #[doc = " was last bound to."]
    #[doc = ""]
    #[doc = " \\note \\p hwloc_pid_t is \\p pid_t on Unix platforms,"]
    #[doc = " and \\p HANDLE on native Windows platforms."]
    #[doc = ""]
    #[doc = " \\note As a special case on Linux, if a tid (thread ID) is supplied"]
    #[doc = " instead of a pid (process ID) and HWLOC_CPUBIND_THREAD is passed in flags,"]
    #[doc = " the binding for that specific thread is returned."]
    #[doc = ""]
    #[doc = " \\note On non-Linux systems, HWLOC_CPUBIND_THREAD can not be used in \\p flags."]
    pub fn hwloc_get_proc_cpubind(
        topology: hwloc_topology_t,
        pid: pid_t,
        set: hwloc_cpuset_t,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Bind a thread \\p thread on CPUs given in physical bitmap \\p set."]
    #[doc = ""]
    #[doc = " \\note \\p hwloc_thread_t is \\p pthread_t on Unix platforms,"]
    #[doc = " and \\p HANDLE on native Windows platforms."]
    #[doc = ""]
    #[doc = " \\note ::HWLOC_CPUBIND_PROCESS can not be used in \\p flags."]
    pub fn hwloc_set_thread_cpubind(
        topology: hwloc_topology_t,
        thread: pthread_t,
        set: hwloc_const_cpuset_t,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get the current physical binding of thread \\p tid."]
    #[doc = ""]
    #[doc = " The CPU-set \\p set (previously allocated by the caller)"]
    #[doc = " is filled with the list of PUs which the thread"]
    #[doc = " was last bound to."]
    #[doc = ""]
    #[doc = " \\note \\p hwloc_thread_t is \\p pthread_t on Unix platforms,"]
    #[doc = " and \\p HANDLE on native Windows platforms."]
    #[doc = ""]
    #[doc = " \\note ::HWLOC_CPUBIND_PROCESS can not be used in \\p flags."]
    pub fn hwloc_get_thread_cpubind(
        topology: hwloc_topology_t,
        thread: pthread_t,
        set: hwloc_cpuset_t,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get the last physical CPU where the current process or thread ran."]
    #[doc = ""]
    #[doc = " The CPU-set \\p set (previously allocated by the caller)"]
    #[doc = " is filled with the list of PUs which the process or"]
    #[doc = " thread (according to \\e flags) last ran on."]
    #[doc = ""]
    #[doc = " The operating system may move some tasks from one processor"]
    #[doc = " to another at any time according to their binding,"]
    #[doc = " so this function may return something that is already"]
    #[doc = " outdated."]
    #[doc = ""]
    #[doc = " \\p flags can include either ::HWLOC_CPUBIND_PROCESS or ::HWLOC_CPUBIND_THREAD to"]
    #[doc = " specify whether the query should be for the whole process (union of all CPUs"]
    #[doc = " on which all threads are running), or only the current thread. If the"]
    #[doc = " process is single-threaded, flags can be set to zero to let hwloc use"]
    #[doc = " whichever method is available on the underlying OS."]
    pub fn hwloc_get_last_cpu_location(
        topology: hwloc_topology_t,
        set: hwloc_cpuset_t,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get the last physical CPU where a process ran."]
    #[doc = ""]
    #[doc = " The CPU-set \\p set (previously allocated by the caller)"]
    #[doc = " is filled with the list of PUs which the process"]
    #[doc = " last ran on."]
    #[doc = ""]
    #[doc = " The operating system may move some tasks from one processor"]
    #[doc = " to another at any time according to their binding,"]
    #[doc = " so this function may return something that is already"]
    #[doc = " outdated."]
    #[doc = ""]
    #[doc = " \\note \\p hwloc_pid_t is \\p pid_t on Unix platforms,"]
    #[doc = " and \\p HANDLE on native Windows platforms."]
    #[doc = ""]
    #[doc = " \\note As a special case on Linux, if a tid (thread ID) is supplied"]
    #[doc = " instead of a pid (process ID) and ::HWLOC_CPUBIND_THREAD is passed in flags,"]
    #[doc = " the last CPU location of that specific thread is returned."]
    #[doc = ""]
    #[doc = " \\note On non-Linux systems, ::HWLOC_CPUBIND_THREAD can not be used in \\p flags."]
    pub fn hwloc_get_proc_last_cpu_location(
        topology: hwloc_topology_t,
        pid: pid_t,
        set: hwloc_cpuset_t,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[doc = " \\brief Reset the memory allocation policy to the system default."]
#[doc = " Depending on the operating system, this may correspond to"]
#[doc = " ::HWLOC_MEMBIND_FIRSTTOUCH (Linux, FreeBSD),"]
#[doc = " or ::HWLOC_MEMBIND_BIND (AIX, HP-UX, Solaris, Windows)."]
#[doc = " This policy is never returned by get membind functions."]
#[doc = " The nodeset argument is ignored."]
#[doc = " \\hideinitializer"]
pub const hwloc_membind_policy_t_HWLOC_MEMBIND_DEFAULT: hwloc_membind_policy_t = 0;
#[doc = " \\brief Allocate each memory page individually on the local NUMA"]
#[doc = " node of the thread that touches it."]
#[doc = ""]
#[doc = " The given nodeset should usually be hwloc_topology_get_topology_nodeset()"]
#[doc = " so that the touching thread may run and allocate on any node in the system."]
#[doc = ""]
#[doc = " On AIX, if the nodeset is smaller, pages are allocated locally (if the local"]
#[doc = " node is in the nodeset) or from a random non-local node (otherwise)."]
#[doc = " \\hideinitializer"]
pub const hwloc_membind_policy_t_HWLOC_MEMBIND_FIRSTTOUCH: hwloc_membind_policy_t = 1;
#[doc = " \\brief Allocate memory on the specified nodes."]
#[doc = " \\hideinitializer"]
pub const hwloc_membind_policy_t_HWLOC_MEMBIND_BIND: hwloc_membind_policy_t = 2;
#[doc = " \\brief Allocate memory on the given nodes in an interleaved"]
#[doc = " / round-robin manner.  The precise layout of the memory across"]
#[doc = " multiple NUMA nodes is OS/system specific. Interleaving can be"]
#[doc = " useful when threads distributed across the specified NUMA nodes"]
#[doc = " will all be accessing the whole memory range concurrently, since"]
#[doc = " the interleave will then balance the memory references."]
#[doc = " \\hideinitializer"]
pub const hwloc_membind_policy_t_HWLOC_MEMBIND_INTERLEAVE: hwloc_membind_policy_t = 3;
#[doc = " \\brief For each page bound with this policy, by next time"]
#[doc = " it is touched (and next time only), it is moved from its current"]
#[doc = " location to the local NUMA node of the thread where the memory"]
#[doc = " reference occurred (if it needs to be moved at all)."]
#[doc = " \\hideinitializer"]
pub const hwloc_membind_policy_t_HWLOC_MEMBIND_NEXTTOUCH: hwloc_membind_policy_t = 4;
#[doc = " \\brief Returned by get_membind() functions when multiple"]
#[doc = " threads or parts of a memory area have differing memory binding"]
#[doc = " policies."]
#[doc = " Also returned when binding is unknown because binding hooks are empty"]
#[doc = " when the topology is loaded from XML without HWLOC_THISSYSTEM=1, etc."]
#[doc = " \\hideinitializer"]
pub const hwloc_membind_policy_t_HWLOC_MEMBIND_MIXED: hwloc_membind_policy_t = -1;
#[doc = " \\brief Memory binding policy."]
#[doc = ""]
#[doc = " These constants can be used to choose the binding policy.  Only one policy can"]
#[doc = " be used at a time (i.e., the values cannot be OR'ed together)."]
#[doc = ""]
#[doc = " Not all systems support all kinds of binding."]
#[doc = " hwloc_topology_get_support() may be used to query about the actual memory"]
#[doc = " binding policy support in the currently used operating system."]
#[doc = " See the \"Detailed Description\" section of \\ref hwlocality_membinding"]
#[doc = " for a description of errors that can occur."]
pub type hwloc_membind_policy_t = ::std::os::raw::c_int;
#[doc = " \\brief Set policy for all threads of the specified (possibly"]
#[doc = " multithreaded) process.  This flag is mutually exclusive with"]
#[doc = " ::HWLOC_MEMBIND_THREAD."]
#[doc = " \\hideinitializer"]
pub const hwloc_membind_flags_t_HWLOC_MEMBIND_PROCESS: hwloc_membind_flags_t = 1;
#[doc = " \\brief Set policy for a specific thread of the current process."]
#[doc = " This flag is mutually exclusive with ::HWLOC_MEMBIND_PROCESS."]
#[doc = " \\hideinitializer"]
pub const hwloc_membind_flags_t_HWLOC_MEMBIND_THREAD: hwloc_membind_flags_t = 2;
#[doc = " Request strict binding from the OS.  The function will fail if"]
#[doc = " the binding can not be guaranteed / completely enforced."]
#[doc = ""]
#[doc = " This flag has slightly different meanings depending on which"]
#[doc = " function it is used with."]
#[doc = " \\hideinitializer"]
pub const hwloc_membind_flags_t_HWLOC_MEMBIND_STRICT: hwloc_membind_flags_t = 4;
#[doc = " \\brief Migrate existing allocated memory.  If the memory cannot"]
#[doc = " be migrated and the ::HWLOC_MEMBIND_STRICT flag is passed, an error"]
#[doc = " will be returned."]
#[doc = " \\hideinitializer"]
pub const hwloc_membind_flags_t_HWLOC_MEMBIND_MIGRATE: hwloc_membind_flags_t = 8;
#[doc = " \\brief Avoid any effect on CPU binding."]
#[doc = ""]
#[doc = " On some operating systems, some underlying memory binding"]
#[doc = " functions also bind the application to the corresponding CPU(s)."]
#[doc = " Using this flag will cause hwloc to avoid using OS functions that"]
#[doc = " could potentially affect CPU bindings.  Note, however, that using"]
#[doc = " NOCPUBIND may reduce hwloc's overall memory binding"]
#[doc = " support. Specifically: some of hwloc's memory binding functions"]
#[doc = " may fail with errno set to ENOSYS when used with NOCPUBIND."]
#[doc = " \\hideinitializer"]
pub const hwloc_membind_flags_t_HWLOC_MEMBIND_NOCPUBIND: hwloc_membind_flags_t = 16;
#[doc = " \\brief Consider the bitmap argument as a nodeset."]
#[doc = ""]
#[doc = " The bitmap argument is considered a nodeset if this flag is given,"]
#[doc = " or a cpuset otherwise by default."]
#[doc = ""]
#[doc = " Memory binding by CPU set cannot work for CPU-less NUMA memory nodes."]
#[doc = " Binding by nodeset should therefore be preferred whenever possible."]
#[doc = " \\hideinitializer"]
pub const hwloc_membind_flags_t_HWLOC_MEMBIND_BYNODESET: hwloc_membind_flags_t = 32;
#[doc = " \\brief Memory binding flags."]
#[doc = ""]
#[doc = " These flags can be used to refine the binding policy."]
#[doc = " All flags can be logically OR'ed together with the exception of"]
#[doc = " ::HWLOC_MEMBIND_PROCESS and ::HWLOC_MEMBIND_THREAD;"]
#[doc = " these two flags are mutually exclusive."]
#[doc = ""]
#[doc = " Not all systems support all kinds of binding."]
#[doc = " hwloc_topology_get_support() may be used to query about the actual memory"]
#[doc = " binding support in the currently used operating system."]
#[doc = " See the \"Detailed Description\" section of \\ref hwlocality_membinding"]
#[doc = " for a description of errors that can occur."]
pub type hwloc_membind_flags_t = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " \\brief Set the default memory binding policy of the current"]
    #[doc = " process or thread to prefer the NUMA node(s) specified by \\p set"]
    #[doc = ""]
    #[doc = " If neither ::HWLOC_MEMBIND_PROCESS nor ::HWLOC_MEMBIND_THREAD is"]
    #[doc = " specified, the current process is assumed to be single-threaded."]
    #[doc = " This is the most portable form as it permits hwloc to use either"]
    #[doc = " process-based OS functions or thread-based OS functions, depending"]
    #[doc = " on which are available."]
    #[doc = ""]
    #[doc = " If ::HWLOC_MEMBIND_BYNODESET is specified, set is considered a nodeset."]
    #[doc = " Otherwise it's a cpuset."]
    #[doc = ""]
    #[doc = " \\return -1 with errno set to ENOSYS if the action is not supported"]
    #[doc = " \\return -1 with errno set to EXDEV if the binding cannot be enforced"]
    pub fn hwloc_set_membind(
        topology: hwloc_topology_t,
        set: hwloc_const_bitmap_t,
        policy: hwloc_membind_policy_t,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Query the default memory binding policy and physical locality of the"]
    #[doc = " current process or thread."]
    #[doc = ""]
    #[doc = " The bitmap \\p set (previously allocated by the caller)"]
    #[doc = " is filled with the process or thread memory binding."]
    #[doc = ""]
    #[doc = " This function has two output parameters: \\p set and \\p policy."]
    #[doc = " The values returned in these parameters depend on both the \\p flags"]
    #[doc = " passed in and the current memory binding policies and nodesets in"]
    #[doc = " the queried target."]
    #[doc = ""]
    #[doc = " Passing the ::HWLOC_MEMBIND_PROCESS flag specifies that the query"]
    #[doc = " target is the current policies and nodesets for all the threads in"]
    #[doc = " the current process.  Passing ::HWLOC_MEMBIND_THREAD specifies that"]
    #[doc = " the query target is the current policy and nodeset for only the"]
    #[doc = " thread invoking this function."]
    #[doc = ""]
    #[doc = " If neither of these flags are passed (which is the most portable"]
    #[doc = " method), the process is assumed to be single threaded.  This allows"]
    #[doc = " hwloc to use either process-based OS functions or thread-based OS"]
    #[doc = " functions, depending on which are available."]
    #[doc = ""]
    #[doc = " ::HWLOC_MEMBIND_STRICT is only meaningful when ::HWLOC_MEMBIND_PROCESS"]
    #[doc = " is also specified.  In this case, hwloc will check the default"]
    #[doc = " memory policies and nodesets for all threads in the process.  If"]
    #[doc = " they are not identical, -1 is returned and errno is set to EXDEV."]
    #[doc = " If they are identical, the values are returned in \\p set and \\p"]
    #[doc = " policy."]
    #[doc = ""]
    #[doc = " Otherwise, if ::HWLOC_MEMBIND_PROCESS is specified (and"]
    #[doc = " ::HWLOC_MEMBIND_STRICT is \\em not specified), the default set"]
    #[doc = " from each thread is logically OR'ed together."]
    #[doc = " If all threads' default policies are the same, \\p policy is set to"]
    #[doc = " that policy.  If they are different, \\p policy is set to"]
    #[doc = " ::HWLOC_MEMBIND_MIXED."]
    #[doc = ""]
    #[doc = " In the ::HWLOC_MEMBIND_THREAD case (or when neither"]
    #[doc = " ::HWLOC_MEMBIND_PROCESS or ::HWLOC_MEMBIND_THREAD is specified), there"]
    #[doc = " is only one set and policy; they are returned in \\p set and"]
    #[doc = " \\p policy, respectively."]
    #[doc = ""]
    #[doc = " If ::HWLOC_MEMBIND_BYNODESET is specified, set is considered a nodeset."]
    #[doc = " Otherwise it's a cpuset."]
    #[doc = ""]
    #[doc = " If any other flags are specified, -1 is returned and errno is set"]
    #[doc = " to EINVAL."]
    pub fn hwloc_get_membind(
        topology: hwloc_topology_t,
        set: hwloc_bitmap_t,
        policy: *mut hwloc_membind_policy_t,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Set the default memory binding policy of the specified"]
    #[doc = " process to prefer the NUMA node(s) specified by \\p set"]
    #[doc = ""]
    #[doc = " If ::HWLOC_MEMBIND_BYNODESET is specified, set is considered a nodeset."]
    #[doc = " Otherwise it's a cpuset."]
    #[doc = ""]
    #[doc = " \\return -1 with errno set to ENOSYS if the action is not supported"]
    #[doc = " \\return -1 with errno set to EXDEV if the binding cannot be enforced"]
    #[doc = ""]
    #[doc = " \\note \\p hwloc_pid_t is \\p pid_t on Unix platforms,"]
    #[doc = " and \\p HANDLE on native Windows platforms."]
    pub fn hwloc_set_proc_membind(
        topology: hwloc_topology_t,
        pid: pid_t,
        set: hwloc_const_bitmap_t,
        policy: hwloc_membind_policy_t,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Query the default memory binding policy and physical locality of the"]
    #[doc = " specified process."]
    #[doc = ""]
    #[doc = " The bitmap \\p set (previously allocated by the caller)"]
    #[doc = " is filled with the process memory binding."]
    #[doc = ""]
    #[doc = " This function has two output parameters: \\p set and \\p policy."]
    #[doc = " The values returned in these parameters depend on both the \\p flags"]
    #[doc = " passed in and the current memory binding policies and nodesets in"]
    #[doc = " the queried target."]
    #[doc = ""]
    #[doc = " Passing the ::HWLOC_MEMBIND_PROCESS flag specifies that the query"]
    #[doc = " target is the current policies and nodesets for all the threads in"]
    #[doc = " the specified process.  If ::HWLOC_MEMBIND_PROCESS is not specified"]
    #[doc = " (which is the most portable method), the process is assumed to be"]
    #[doc = " single threaded.  This allows hwloc to use either process-based OS"]
    #[doc = " functions or thread-based OS functions, depending on which are"]
    #[doc = " available."]
    #[doc = ""]
    #[doc = " Note that it does not make sense to pass ::HWLOC_MEMBIND_THREAD to"]
    #[doc = " this function."]
    #[doc = ""]
    #[doc = " If ::HWLOC_MEMBIND_STRICT is specified, hwloc will check the default"]
    #[doc = " memory policies and nodesets for all threads in the specified"]
    #[doc = " process.  If they are not identical, -1 is returned and errno is"]
    #[doc = " set to EXDEV.  If they are identical, the values are returned in \\p"]
    #[doc = " set and \\p policy."]
    #[doc = ""]
    #[doc = " Otherwise, \\p set is set to the logical OR of all threads'"]
    #[doc = " default set.  If all threads' default policies"]
    #[doc = " are the same, \\p policy is set to that policy.  If they are"]
    #[doc = " different, \\p policy is set to ::HWLOC_MEMBIND_MIXED."]
    #[doc = ""]
    #[doc = " If ::HWLOC_MEMBIND_BYNODESET is specified, set is considered a nodeset."]
    #[doc = " Otherwise it's a cpuset."]
    #[doc = ""]
    #[doc = " If any other flags are specified, -1 is returned and errno is set"]
    #[doc = " to EINVAL."]
    #[doc = ""]
    #[doc = " \\note \\p hwloc_pid_t is \\p pid_t on Unix platforms,"]
    #[doc = " and \\p HANDLE on native Windows platforms."]
    pub fn hwloc_get_proc_membind(
        topology: hwloc_topology_t,
        pid: pid_t,
        set: hwloc_bitmap_t,
        policy: *mut hwloc_membind_policy_t,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Bind the already-allocated memory identified by (addr, len)"]
    #[doc = " to the NUMA node(s) specified by \\p set."]
    #[doc = ""]
    #[doc = " If ::HWLOC_MEMBIND_BYNODESET is specified, set is considered a nodeset."]
    #[doc = " Otherwise it's a cpuset."]
    #[doc = ""]
    #[doc = " \\return 0 if \\p len is 0."]
    #[doc = " \\return -1 with errno set to ENOSYS if the action is not supported"]
    #[doc = " \\return -1 with errno set to EXDEV if the binding cannot be enforced"]
    pub fn hwloc_set_area_membind(
        topology: hwloc_topology_t,
        addr: *const ::std::os::raw::c_void,
        len: size_t,
        set: hwloc_const_bitmap_t,
        policy: hwloc_membind_policy_t,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Query the CPUs near the physical NUMA node(s) and binding policy of"]
    #[doc = " the memory identified by (\\p addr, \\p len )."]
    #[doc = ""]
    #[doc = " The bitmap \\p set (previously allocated by the caller)"]
    #[doc = " is filled with the memory area binding."]
    #[doc = ""]
    #[doc = " This function has two output parameters: \\p set and \\p policy."]
    #[doc = " The values returned in these parameters depend on both the \\p flags"]
    #[doc = " passed in and the memory binding policies and nodesets of the pages"]
    #[doc = " in the address range."]
    #[doc = ""]
    #[doc = " If ::HWLOC_MEMBIND_STRICT is specified, the target pages are first"]
    #[doc = " checked to see if they all have the same memory binding policy and"]
    #[doc = " nodeset.  If they do not, -1 is returned and errno is set to EXDEV."]
    #[doc = " If they are identical across all pages, the set and policy are"]
    #[doc = " returned in \\p set and \\p policy, respectively."]
    #[doc = ""]
    #[doc = " If ::HWLOC_MEMBIND_STRICT is not specified, the union of all NUMA"]
    #[doc = " node(s) containing pages in the address range is calculated."]
    #[doc = " If all pages in the target have the same policy, it is returned in"]
    #[doc = " \\p policy.  Otherwise, \\p policy is set to ::HWLOC_MEMBIND_MIXED."]
    #[doc = ""]
    #[doc = " If ::HWLOC_MEMBIND_BYNODESET is specified, set is considered a nodeset."]
    #[doc = " Otherwise it's a cpuset."]
    #[doc = ""]
    #[doc = " If any other flags are specified, -1 is returned and errno is set"]
    #[doc = " to EINVAL."]
    #[doc = ""]
    #[doc = " If \\p len is 0, -1 is returned and errno is set to EINVAL."]
    pub fn hwloc_get_area_membind(
        topology: hwloc_topology_t,
        addr: *const ::std::os::raw::c_void,
        len: size_t,
        set: hwloc_bitmap_t,
        policy: *mut hwloc_membind_policy_t,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get the NUMA nodes where memory identified by (\\p addr, \\p len ) is physically allocated."]
    #[doc = ""]
    #[doc = " The bitmap \\p set (previously allocated by the caller)"]
    #[doc = " is filled according to the NUMA nodes where the memory area pages"]
    #[doc = " are physically allocated. If no page is actually allocated yet,"]
    #[doc = " \\p set may be empty."]
    #[doc = ""]
    #[doc = " If pages spread to multiple nodes, it is not specified whether they spread"]
    #[doc = " equitably, or whether most of them are on a single node, etc."]
    #[doc = ""]
    #[doc = " The operating system may move memory pages from one processor"]
    #[doc = " to another at any time according to their binding,"]
    #[doc = " so this function may return something that is already"]
    #[doc = " outdated."]
    #[doc = ""]
    #[doc = " If ::HWLOC_MEMBIND_BYNODESET is specified in \\p flags, set is"]
    #[doc = " considered a nodeset. Otherwise it's a cpuset."]
    #[doc = ""]
    #[doc = " If \\p len is 0, \\p set is emptied."]
    pub fn hwloc_get_area_memlocation(
        topology: hwloc_topology_t,
        addr: *const ::std::os::raw::c_void,
        len: size_t,
        set: hwloc_bitmap_t,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Allocate some memory"]
    #[doc = ""]
    #[doc = " This is equivalent to malloc(), except that it tries to allocate"]
    #[doc = " page-aligned memory from the OS."]
    #[doc = ""]
    #[doc = " \\note The allocated memory should be freed with hwloc_free()."]
    pub fn hwloc_alloc(topology: hwloc_topology_t, len: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " \\brief Allocate some memory on NUMA memory nodes specified by \\p set"]
    #[doc = ""]
    #[doc = " \\return NULL with errno set to ENOSYS if the action is not supported"]
    #[doc = " and ::HWLOC_MEMBIND_STRICT is given"]
    #[doc = " \\return NULL with errno set to EXDEV if the binding cannot be enforced"]
    #[doc = " and ::HWLOC_MEMBIND_STRICT is given"]
    #[doc = " \\return NULL with errno set to ENOMEM if the memory allocation failed"]
    #[doc = " even before trying to bind."]
    #[doc = ""]
    #[doc = " If ::HWLOC_MEMBIND_BYNODESET is specified, set is considered a nodeset."]
    #[doc = " Otherwise it's a cpuset."]
    #[doc = ""]
    #[doc = " \\note The allocated memory should be freed with hwloc_free()."]
    pub fn hwloc_alloc_membind(
        topology: hwloc_topology_t,
        len: size_t,
        set: hwloc_const_bitmap_t,
        policy: hwloc_membind_policy_t,
        flags: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " \\brief Free memory that was previously allocated by hwloc_alloc()"]
    #[doc = " or hwloc_alloc_membind()."]
    pub fn hwloc_free(
        topology: hwloc_topology_t,
        addr: *mut ::std::os::raw::c_void,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Change which process the topology is viewed from."]
    #[doc = ""]
    #[doc = " On some systems, processes may have different views of the machine, for"]
    #[doc = " instance the set of allowed CPUs. By default, hwloc exposes the view from"]
    #[doc = " the current process. Calling hwloc_topology_set_pid() permits to make it"]
    #[doc = " expose the topology of the machine from the point of view of another"]
    #[doc = " process."]
    #[doc = ""]
    #[doc = " \\note \\p hwloc_pid_t is \\p pid_t on Unix platforms,"]
    #[doc = " and \\p HANDLE on native Windows platforms."]
    #[doc = ""]
    #[doc = " \\note -1 is returned and errno is set to ENOSYS on platforms that do not"]
    #[doc = " support this feature."]
    pub fn hwloc_topology_set_pid(topology: hwloc_topology_t, pid: pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Enable synthetic topology."]
    #[doc = ""]
    #[doc = " Gather topology information from the given \\p description,"]
    #[doc = " a space-separated string of <type:number> describing"]
    #[doc = " the object type and arity at each level."]
    #[doc = " All types may be omitted (space-separated string of numbers) so that"]
    #[doc = " hwloc chooses all types according to usual topologies."]
    #[doc = " See also the \\ref synthetic."]
    #[doc = ""]
    #[doc = " Setting the environment variable HWLOC_SYNTHETIC"]
    #[doc = " may also result in this behavior."]
    #[doc = ""]
    #[doc = " If \\p description was properly parsed and describes a valid topology"]
    #[doc = " configuration, this function returns 0."]
    #[doc = " Otherwise -1 is returned and errno is set to EINVAL."]
    #[doc = ""]
    #[doc = " Note that this function does not actually load topology"]
    #[doc = " information; it just tells hwloc where to load it from.  You'll"]
    #[doc = " still need to invoke hwloc_topology_load() to actually load the"]
    #[doc = " topology information."]
    #[doc = ""]
    #[doc = " \\note For convenience, this backend provides empty binding hooks which just"]
    #[doc = " return success."]
    #[doc = ""]
    #[doc = " \\note On success, the synthetic component replaces the previously enabled"]
    #[doc = " component (if any), but the topology is not actually modified until"]
    #[doc = " hwloc_topology_load()."]
    pub fn hwloc_topology_set_synthetic(
        topology: hwloc_topology_t,
        description: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Enable XML-file based topology."]
    #[doc = ""]
    #[doc = " Gather topology information from the XML file given at \\p xmlpath."]
    #[doc = " Setting the environment variable HWLOC_XMLFILE may also result in this behavior."]
    #[doc = " This file may have been generated earlier with hwloc_topology_export_xml() in hwloc/export.h,"]
    #[doc = " or lstopo file.xml."]
    #[doc = ""]
    #[doc = " Note that this function does not actually load topology"]
    #[doc = " information; it just tells hwloc where to load it from.  You'll"]
    #[doc = " still need to invoke hwloc_topology_load() to actually load the"]
    #[doc = " topology information."]
    #[doc = ""]
    #[doc = " \\return -1 with errno set to EINVAL on failure to read the XML file."]
    #[doc = ""]
    #[doc = " \\note See also hwloc_topology_set_userdata_import_callback()"]
    #[doc = " for importing application-specific object userdata."]
    #[doc = ""]
    #[doc = " \\note For convenience, this backend provides empty binding hooks which just"]
    #[doc = " return success.  To have hwloc still actually call OS-specific hooks, the"]
    #[doc = " ::HWLOC_TOPOLOGY_FLAG_IS_THISSYSTEM has to be set to assert that the loaded"]
    #[doc = " file is really the underlying system."]
    #[doc = ""]
    #[doc = " \\note On success, the XML component replaces the previously enabled"]
    #[doc = " component (if any), but the topology is not actually modified until"]
    #[doc = " hwloc_topology_load()."]
    pub fn hwloc_topology_set_xml(
        topology: hwloc_topology_t,
        xmlpath: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Enable XML based topology using a memory buffer (instead of"]
    #[doc = " a file, as with hwloc_topology_set_xml())."]
    #[doc = ""]
    #[doc = " Gather topology information from the XML memory buffer given at \\p"]
    #[doc = " buffer and of length \\p size.  This buffer may have been filled"]
    #[doc = " earlier with hwloc_topology_export_xmlbuffer() in hwloc/export.h."]
    #[doc = ""]
    #[doc = " Note that this function does not actually load topology"]
    #[doc = " information; it just tells hwloc where to load it from.  You'll"]
    #[doc = " still need to invoke hwloc_topology_load() to actually load the"]
    #[doc = " topology information."]
    #[doc = ""]
    #[doc = " \\return -1 with errno set to EINVAL on failure to read the XML buffer."]
    #[doc = ""]
    #[doc = " \\note See also hwloc_topology_set_userdata_import_callback()"]
    #[doc = " for importing application-specific object userdata."]
    #[doc = ""]
    #[doc = " \\note For convenience, this backend provides empty binding hooks which just"]
    #[doc = " return success.  To have hwloc still actually call OS-specific hooks, the"]
    #[doc = " ::HWLOC_TOPOLOGY_FLAG_IS_THISSYSTEM has to be set to assert that the loaded"]
    #[doc = " file is really the underlying system."]
    #[doc = ""]
    #[doc = " \\note On success, the XML component replaces the previously enabled"]
    #[doc = " component (if any), but the topology is not actually modified until"]
    #[doc = " hwloc_topology_load()."]
    pub fn hwloc_topology_set_xmlbuffer(
        topology: hwloc_topology_t,
        buffer: *const ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[doc = " \\brief Blacklist the target component from being used."]
#[doc = " \\hideinitializer"]
pub const hwloc_topology_components_flag_e_HWLOC_TOPOLOGY_COMPONENTS_FLAG_BLACKLIST:
    hwloc_topology_components_flag_e = 1;
#[doc = " \\brief Flags to be passed to hwloc_topology_set_components()"]
pub type hwloc_topology_components_flag_e = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " \\brief Prevent a discovery component from being used for a topology."]
    #[doc = ""]
    #[doc = " \\p name is the name of the discovery component that should not be used"]
    #[doc = " when loading topology \\p topology. The name is a string such as \"cuda\"."]
    #[doc = ""]
    #[doc = " For components with multiple phases, it may also be suffixed with the name"]
    #[doc = " of a phase, for instance \"linux:io\"."]
    #[doc = ""]
    #[doc = " \\p flags should be ::HWLOC_TOPOLOGY_COMPONENTS_FLAG_BLACKLIST."]
    #[doc = ""]
    #[doc = " This may be used to avoid expensive parts of the discovery process."]
    #[doc = " For instance, CUDA-specific discovery may be expensive and unneeded"]
    #[doc = " while generic I/O discovery could still be useful."]
    pub fn hwloc_topology_set_components(
        topology: hwloc_topology_t,
        flags: ::std::os::raw::c_ulong,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[doc = " \\brief Detect the whole system, ignore reservations, include disallowed objects."]
#[doc = ""]
#[doc = " Gather all online resources, even if some were disabled by the administrator."]
#[doc = " For instance, ignore Linux Cgroup/Cpusets and gather all processors and memory nodes."]
#[doc = " However offline PUs and NUMA nodes are still ignored."]
#[doc = ""]
#[doc = " When this flag is not set, PUs and NUMA nodes that are disallowed are not added to the topology."]
#[doc = " Parent objects (package, core, cache, etc.) are added only if some of their children are allowed."]
#[doc = " All existing PUs and NUMA nodes in the topology are allowed."]
#[doc = " hwloc_topology_get_allowed_cpuset() and hwloc_topology_get_allowed_nodeset()"]
#[doc = " are equal to the root object cpuset and nodeset."]
#[doc = ""]
#[doc = " When this flag is set, the actual sets of allowed PUs and NUMA nodes are given"]
#[doc = " by hwloc_topology_get_allowed_cpuset() and hwloc_topology_get_allowed_nodeset()."]
#[doc = " They may be smaller than the root object cpuset and nodeset."]
#[doc = ""]
#[doc = " If the current topology is exported to XML and reimported later, this flag"]
#[doc = " should be set again in the reimported topology so that disallowed resources"]
#[doc = " are reimported as well."]
#[doc = " \\hideinitializer"]
pub const hwloc_topology_flags_e_HWLOC_TOPOLOGY_FLAG_INCLUDE_DISALLOWED: hwloc_topology_flags_e = 1;
#[doc = " \\brief Assume that the selected backend provides the topology for the"]
#[doc = " system on which we are running."]
#[doc = ""]
#[doc = " This forces hwloc_topology_is_thissystem() to return 1, i.e. makes hwloc assume that"]
#[doc = " the selected backend provides the topology for the system on which we are running,"]
#[doc = " even if it is not the OS-specific backend but the XML backend for instance."]
#[doc = " This means making the binding functions actually call the OS-specific"]
#[doc = " system calls and really do binding, while the XML backend would otherwise"]
#[doc = " provide empty hooks just returning success."]
#[doc = ""]
#[doc = " Setting the environment variable HWLOC_THISSYSTEM may also result in the"]
#[doc = " same behavior."]
#[doc = ""]
#[doc = " This can be used for efficiency reasons to first detect the topology once,"]
#[doc = " save it to an XML file, and quickly reload it later through the XML"]
#[doc = " backend, but still having binding functions actually do bind."]
#[doc = " \\hideinitializer"]
pub const hwloc_topology_flags_e_HWLOC_TOPOLOGY_FLAG_IS_THISSYSTEM: hwloc_topology_flags_e = 2;
#[doc = " \\brief Get the set of allowed resources from the local operating system even if the topology was loaded from XML or synthetic description."]
#[doc = ""]
#[doc = " If the topology was loaded from XML or from a synthetic string,"]
#[doc = " restrict it by applying the current process restrictions such as"]
#[doc = " Linux Cgroup/Cpuset."]
#[doc = ""]
#[doc = " This is useful when the topology is not loaded directly from"]
#[doc = " the local machine (e.g. for performance reason) and it comes"]
#[doc = " with all resources, while the running process is restricted"]
#[doc = " to only parts of the machine."]
#[doc = ""]
#[doc = " This flag is ignored unless ::HWLOC_TOPOLOGY_FLAG_IS_THISSYSTEM is"]
#[doc = " also set since the loaded topology must match the underlying machine"]
#[doc = " where restrictions will be gathered from."]
#[doc = ""]
#[doc = " Setting the environment variable HWLOC_THISSYSTEM_ALLOWED_RESOURCES"]
#[doc = " would result in the same behavior."]
#[doc = " \\hideinitializer"]
pub const hwloc_topology_flags_e_HWLOC_TOPOLOGY_FLAG_THISSYSTEM_ALLOWED_RESOURCES:
    hwloc_topology_flags_e = 4;
#[doc = " \\brief Import support from the imported topology."]
#[doc = ""]
#[doc = " When importing a XML topology from a remote machine, binding is"]
#[doc = " disabled by default (see ::HWLOC_TOPOLOGY_FLAG_IS_THISSYSTEM)."]
#[doc = " This disabling is also marked by putting zeroes in the corresponding"]
#[doc = " supported feature bits reported by hwloc_topology_get_support()."]
#[doc = ""]
#[doc = " The flag ::HWLOC_TOPOLOGY_FLAG_IMPORT_SUPPORT actually imports"]
#[doc = " support bits from the remote machine. It also sets the flag"]
#[doc = " \\p imported_support in the struct hwloc_topology_misc_support array."]
#[doc = " If the imported XML did not contain any support information"]
#[doc = " (exporter hwloc is too old), this flag is not set."]
#[doc = ""]
#[doc = " Note that these supported features are only relevant for the hwloc"]
#[doc = " installation that actually exported the XML topology"]
#[doc = " (it may vary with the operating system, or with how hwloc was compiled)."]
#[doc = ""]
#[doc = " Note that setting this flag however does not enable binding for the"]
#[doc = " locally imported hwloc topology, it only reports what the remote"]
#[doc = " hwloc and machine support."]
#[doc = ""]
pub const hwloc_topology_flags_e_HWLOC_TOPOLOGY_FLAG_IMPORT_SUPPORT: hwloc_topology_flags_e = 8;
#[doc = " \\brief Do not consider resources outside of the process CPU binding."]
#[doc = ""]
#[doc = " If the binding of the process is limited to a subset of cores,"]
#[doc = " ignore the other cores during discovery."]
#[doc = ""]
#[doc = " The resulting topology is identical to what a call to hwloc_topology_restrict()"]
#[doc = " would generate, but this flag also prevents hwloc from ever touching other"]
#[doc = " resources during the discovery."]
#[doc = ""]
#[doc = " This flag especially tells the x86 backend to never temporarily"]
#[doc = " rebind a thread on any excluded core. This is useful on Windows"]
#[doc = " because such temporary rebinding can change the process binding."]
#[doc = " Another use-case is to avoid cores that would not be able to"]
#[doc = " perform the hwloc discovery anytime soon because they are busy"]
#[doc = " executing some high-priority real-time tasks."]
#[doc = ""]
#[doc = " If process CPU binding is not supported,"]
#[doc = " the thread CPU binding is considered instead if supported,"]
#[doc = " or the flag is ignored."]
#[doc = ""]
#[doc = " This flag requires ::HWLOC_TOPOLOGY_FLAG_IS_THISSYSTEM as well"]
#[doc = " since binding support is required."]
pub const hwloc_topology_flags_e_HWLOC_TOPOLOGY_FLAG_RESTRICT_TO_CPUBINDING:
    hwloc_topology_flags_e = 16;
#[doc = " \\brief Do not consider resources outside of the process memory binding."]
#[doc = ""]
#[doc = " If the binding of the process is limited to a subset of NUMA nodes,"]
#[doc = " ignore the other NUMA nodes during discovery."]
#[doc = ""]
#[doc = " The resulting topology is identical to what a call to hwloc_topology_restrict()"]
#[doc = " would generate, but this flag also prevents hwloc from ever touching other"]
#[doc = " resources during the discovery."]
#[doc = ""]
#[doc = " This flag is meant to be used together with"]
#[doc = " ::HWLOC_TOPOLOGY_FLAG_RESTRICT_TO_CPUBINDING when both cores"]
#[doc = " and NUMA nodes should be ignored outside of the process binding."]
#[doc = ""]
#[doc = " If process memory binding is not supported,"]
#[doc = " the thread memory binding is considered instead if supported,"]
#[doc = " or the flag is ignored."]
#[doc = ""]
#[doc = " This flag requires ::HWLOC_TOPOLOGY_FLAG_IS_THISSYSTEM as well"]
#[doc = " since binding support is required."]
pub const hwloc_topology_flags_e_HWLOC_TOPOLOGY_FLAG_RESTRICT_TO_MEMBINDING:
    hwloc_topology_flags_e = 32;
#[doc = " \\brief Do not ever modify the process or thread binding during discovery."]
#[doc = ""]
#[doc = " This flag disables all hwloc discovery steps that require a change of"]
#[doc = " the process or thread binding. This currently only affects the x86"]
#[doc = " backend which gets entirely disabled."]
#[doc = ""]
#[doc = " This is useful when hwloc_topology_load() is called while the"]
#[doc = " application also creates additional threads or modifies the binding."]
#[doc = ""]
#[doc = " This flag is also a strict way to make sure the process binding will"]
#[doc = " not change to due thread binding changes on Windows"]
#[doc = " (see ::HWLOC_TOPOLOGY_FLAG_RESTRICT_TO_CPUBINDING)."]
pub const hwloc_topology_flags_e_HWLOC_TOPOLOGY_FLAG_DONT_CHANGE_BINDING: hwloc_topology_flags_e =
    64;
#[doc = " \\brief Flags to be set onto a topology context before load."]
#[doc = ""]
#[doc = " Flags should be given to hwloc_topology_set_flags()."]
#[doc = " They may also be returned by hwloc_topology_get_flags()."]
pub type hwloc_topology_flags_e = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " \\brief Set OR'ed flags to non-yet-loaded topology."]
    #[doc = ""]
    #[doc = " Set a OR'ed set of ::hwloc_topology_flags_e onto a topology that was not yet loaded."]
    #[doc = ""]
    #[doc = " If this function is called multiple times, the last invocation will erase"]
    #[doc = " and replace the set of flags that was previously set."]
    #[doc = ""]
    #[doc = " By default, no flags are set (\\c 0)."]
    #[doc = ""]
    #[doc = " The flags set in a topology may be retrieved with hwloc_topology_get_flags()."]
    pub fn hwloc_topology_set_flags(
        topology: hwloc_topology_t,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get OR'ed flags of a topology."]
    #[doc = ""]
    #[doc = " Get the OR'ed set of ::hwloc_topology_flags_e of a topology."]
    #[doc = ""]
    #[doc = " If hwloc_topology_set_flags() was not called earlier,"]
    #[doc = " no flags are set (\\c 0 is returned)."]
    #[doc = ""]
    #[doc = " \\return the flags previously set with hwloc_topology_set_flags()."]
    pub fn hwloc_topology_get_flags(topology: hwloc_topology_t) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " \\brief Does the topology context come from this system?"]
    #[doc = ""]
    #[doc = " \\return 1 if this topology context was built using the system"]
    #[doc = " running this program."]
    #[doc = " \\return 0 instead (for instance if using another file-system root,"]
    #[doc = " a XML topology file, or a synthetic topology)."]
    pub fn hwloc_topology_is_thissystem(topology: hwloc_topology_t) -> ::std::os::raw::c_int;
}
#[doc = " \\brief Flags describing actual discovery support for this topology."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hwloc_topology_discovery_support {
    #[doc = " \\brief Detecting the number of PU objects is supported."]
    pub pu: ::std::os::raw::c_uchar,
    #[doc = " \\brief Detecting the number of NUMA nodes is supported."]
    pub numa: ::std::os::raw::c_uchar,
    #[doc = " \\brief Detecting the amount of memory in NUMA nodes is supported."]
    pub numa_memory: ::std::os::raw::c_uchar,
    #[doc = " \\brief Detecting and identifying PU objects that are not available to the current process is supported."]
    pub disallowed_pu: ::std::os::raw::c_uchar,
    #[doc = " \\brief Detecting and identifying NUMA nodes that are not available to the current process is supported."]
    pub disallowed_numa: ::std::os::raw::c_uchar,
    #[doc = " \\brief Detecting the efficiency of CPU kinds is supported, see \\ref hwlocality_cpukinds."]
    pub cpukind_efficiency: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_hwloc_topology_discovery_support() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_topology_discovery_support>(),
        6usize,
        concat!("Size of: ", stringify!(hwloc_topology_discovery_support))
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_topology_discovery_support>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hwloc_topology_discovery_support)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_discovery_support>())).pu as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_discovery_support),
            "::",
            stringify!(pu)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_discovery_support>())).numa as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_discovery_support),
            "::",
            stringify!(numa)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_discovery_support>())).numa_memory as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_discovery_support),
            "::",
            stringify!(numa_memory)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_discovery_support>())).disallowed_pu as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_discovery_support),
            "::",
            stringify!(disallowed_pu)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_discovery_support>())).disallowed_numa as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_discovery_support),
            "::",
            stringify!(disallowed_numa)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_discovery_support>())).cpukind_efficiency
                as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_discovery_support),
            "::",
            stringify!(cpukind_efficiency)
        )
    );
}
#[doc = " \\brief Flags describing actual PU binding support for this topology."]
#[doc = ""]
#[doc = " A flag may be set even if the feature isn't supported in all cases"]
#[doc = " (e.g. binding to random sets of non-contiguous objects)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hwloc_topology_cpubind_support {
    #[doc = " Binding the whole current process is supported."]
    pub set_thisproc_cpubind: ::std::os::raw::c_uchar,
    #[doc = " Getting the binding of the whole current process is supported."]
    pub get_thisproc_cpubind: ::std::os::raw::c_uchar,
    #[doc = " Binding a whole given process is supported."]
    pub set_proc_cpubind: ::std::os::raw::c_uchar,
    #[doc = " Getting the binding of a whole given process is supported."]
    pub get_proc_cpubind: ::std::os::raw::c_uchar,
    #[doc = " Binding the current thread only is supported."]
    pub set_thisthread_cpubind: ::std::os::raw::c_uchar,
    #[doc = " Getting the binding of the current thread only is supported."]
    pub get_thisthread_cpubind: ::std::os::raw::c_uchar,
    #[doc = " Binding a given thread only is supported."]
    pub set_thread_cpubind: ::std::os::raw::c_uchar,
    #[doc = " Getting the binding of a given thread only is supported."]
    pub get_thread_cpubind: ::std::os::raw::c_uchar,
    #[doc = " Getting the last processors where the whole current process ran is supported"]
    pub get_thisproc_last_cpu_location: ::std::os::raw::c_uchar,
    #[doc = " Getting the last processors where a whole process ran is supported"]
    pub get_proc_last_cpu_location: ::std::os::raw::c_uchar,
    #[doc = " Getting the last processors where the current thread ran is supported"]
    pub get_thisthread_last_cpu_location: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_hwloc_topology_cpubind_support() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_topology_cpubind_support>(),
        11usize,
        concat!("Size of: ", stringify!(hwloc_topology_cpubind_support))
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_topology_cpubind_support>(),
        1usize,
        concat!("Alignment of ", stringify!(hwloc_topology_cpubind_support))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_cpubind_support>())).set_thisproc_cpubind
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_cpubind_support),
            "::",
            stringify!(set_thisproc_cpubind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_cpubind_support>())).get_thisproc_cpubind
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_cpubind_support),
            "::",
            stringify!(get_thisproc_cpubind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_cpubind_support>())).set_proc_cpubind as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_cpubind_support),
            "::",
            stringify!(set_proc_cpubind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_cpubind_support>())).get_proc_cpubind as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_cpubind_support),
            "::",
            stringify!(get_proc_cpubind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_cpubind_support>())).set_thisthread_cpubind
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_cpubind_support),
            "::",
            stringify!(set_thisthread_cpubind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_cpubind_support>())).get_thisthread_cpubind
                as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_cpubind_support),
            "::",
            stringify!(get_thisthread_cpubind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_cpubind_support>())).set_thread_cpubind
                as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_cpubind_support),
            "::",
            stringify!(set_thread_cpubind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_cpubind_support>())).get_thread_cpubind
                as *const _ as usize
        },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_cpubind_support),
            "::",
            stringify!(get_thread_cpubind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_cpubind_support>()))
                .get_thisproc_last_cpu_location as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_cpubind_support),
            "::",
            stringify!(get_thisproc_last_cpu_location)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_cpubind_support>())).get_proc_last_cpu_location
                as *const _ as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_cpubind_support),
            "::",
            stringify!(get_proc_last_cpu_location)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_cpubind_support>()))
                .get_thisthread_last_cpu_location as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_cpubind_support),
            "::",
            stringify!(get_thisthread_last_cpu_location)
        )
    );
}
#[doc = " \\brief Flags describing actual memory binding support for this topology."]
#[doc = ""]
#[doc = " A flag may be set even if the feature isn't supported in all cases"]
#[doc = " (e.g. binding to random sets of non-contiguous objects)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hwloc_topology_membind_support {
    #[doc = " Binding the whole current process is supported."]
    pub set_thisproc_membind: ::std::os::raw::c_uchar,
    #[doc = " Getting the binding of the whole current process is supported."]
    pub get_thisproc_membind: ::std::os::raw::c_uchar,
    #[doc = " Binding a whole given process is supported."]
    pub set_proc_membind: ::std::os::raw::c_uchar,
    #[doc = " Getting the binding of a whole given process is supported."]
    pub get_proc_membind: ::std::os::raw::c_uchar,
    #[doc = " Binding the current thread only is supported."]
    pub set_thisthread_membind: ::std::os::raw::c_uchar,
    #[doc = " Getting the binding of the current thread only is supported."]
    pub get_thisthread_membind: ::std::os::raw::c_uchar,
    #[doc = " Binding a given memory area is supported."]
    pub set_area_membind: ::std::os::raw::c_uchar,
    #[doc = " Getting the binding of a given memory area is supported."]
    pub get_area_membind: ::std::os::raw::c_uchar,
    #[doc = " Allocating a bound memory area is supported."]
    pub alloc_membind: ::std::os::raw::c_uchar,
    #[doc = " First-touch policy is supported."]
    pub firsttouch_membind: ::std::os::raw::c_uchar,
    #[doc = " Bind policy is supported."]
    pub bind_membind: ::std::os::raw::c_uchar,
    #[doc = " Interleave policy is supported."]
    pub interleave_membind: ::std::os::raw::c_uchar,
    #[doc = " Next-touch migration policy is supported."]
    pub nexttouch_membind: ::std::os::raw::c_uchar,
    #[doc = " Migration flags is supported."]
    pub migrate_membind: ::std::os::raw::c_uchar,
    #[doc = " Getting the last NUMA nodes where a memory area was allocated is supported"]
    pub get_area_memlocation: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_hwloc_topology_membind_support() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_topology_membind_support>(),
        15usize,
        concat!("Size of: ", stringify!(hwloc_topology_membind_support))
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_topology_membind_support>(),
        1usize,
        concat!("Alignment of ", stringify!(hwloc_topology_membind_support))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_membind_support>())).set_thisproc_membind
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_membind_support),
            "::",
            stringify!(set_thisproc_membind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_membind_support>())).get_thisproc_membind
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_membind_support),
            "::",
            stringify!(get_thisproc_membind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_membind_support>())).set_proc_membind as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_membind_support),
            "::",
            stringify!(set_proc_membind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_membind_support>())).get_proc_membind as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_membind_support),
            "::",
            stringify!(get_proc_membind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_membind_support>())).set_thisthread_membind
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_membind_support),
            "::",
            stringify!(set_thisthread_membind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_membind_support>())).get_thisthread_membind
                as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_membind_support),
            "::",
            stringify!(get_thisthread_membind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_membind_support>())).set_area_membind as *const _
                as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_membind_support),
            "::",
            stringify!(set_area_membind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_membind_support>())).get_area_membind as *const _
                as usize
        },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_membind_support),
            "::",
            stringify!(get_area_membind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_membind_support>())).alloc_membind as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_membind_support),
            "::",
            stringify!(alloc_membind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_membind_support>())).firsttouch_membind
                as *const _ as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_membind_support),
            "::",
            stringify!(firsttouch_membind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_membind_support>())).bind_membind as *const _
                as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_membind_support),
            "::",
            stringify!(bind_membind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_membind_support>())).interleave_membind
                as *const _ as usize
        },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_membind_support),
            "::",
            stringify!(interleave_membind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_membind_support>())).nexttouch_membind as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_membind_support),
            "::",
            stringify!(nexttouch_membind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_membind_support>())).migrate_membind as *const _
                as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_membind_support),
            "::",
            stringify!(migrate_membind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_membind_support>())).get_area_memlocation
                as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_membind_support),
            "::",
            stringify!(get_area_memlocation)
        )
    );
}
#[doc = " \\brief Flags describing miscellaneous features."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hwloc_topology_misc_support {
    #[doc = " Support was imported when importing another topology, see ::HWLOC_TOPOLOGY_FLAG_IMPORT_SUPPORT."]
    pub imported_support: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_hwloc_topology_misc_support() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_topology_misc_support>(),
        1usize,
        concat!("Size of: ", stringify!(hwloc_topology_misc_support))
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_topology_misc_support>(),
        1usize,
        concat!("Alignment of ", stringify!(hwloc_topology_misc_support))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_misc_support>())).imported_support as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_misc_support),
            "::",
            stringify!(imported_support)
        )
    );
}
#[doc = " \\brief Set of flags describing actual support for this topology."]
#[doc = ""]
#[doc = " This is retrieved with hwloc_topology_get_support() and will be valid until"]
#[doc = " the topology object is destroyed.  Note: the values are correct only after"]
#[doc = " discovery."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hwloc_topology_support {
    pub discovery: *mut hwloc_topology_discovery_support,
    pub cpubind: *mut hwloc_topology_cpubind_support,
    pub membind: *mut hwloc_topology_membind_support,
    pub misc: *mut hwloc_topology_misc_support,
}
#[test]
fn bindgen_test_layout_hwloc_topology_support() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_topology_support>(),
        32usize,
        concat!("Size of: ", stringify!(hwloc_topology_support))
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_topology_support>(),
        8usize,
        concat!("Alignment of ", stringify!(hwloc_topology_support))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_support>())).discovery as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_support),
            "::",
            stringify!(discovery)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_topology_support>())).cpubind as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_support),
            "::",
            stringify!(cpubind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_topology_support>())).membind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_support),
            "::",
            stringify!(membind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_topology_support>())).misc as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_support),
            "::",
            stringify!(misc)
        )
    );
}
extern "C" {
    #[doc = " \\brief Retrieve the topology support."]
    #[doc = ""]
    #[doc = " Each flag indicates whether a feature is supported."]
    #[doc = " If set to 0, the feature is not supported."]
    #[doc = " If set to 1, the feature is supported, but the corresponding"]
    #[doc = " call may still fail in some corner cases."]
    #[doc = ""]
    #[doc = " These features are also listed by hwloc-info \\--support"]
    #[doc = ""]
    #[doc = " The reported features are what the current topology supports"]
    #[doc = " on the current machine. If the topology was exported to XML"]
    #[doc = " from another machine and later imported here, support still"]
    #[doc = " describes what is supported for this imported topology after"]
    #[doc = " import. By default, binding will be reported as unsupported"]
    #[doc = " in this case (see ::HWLOC_TOPOLOGY_FLAG_IS_THISSYSTEM)."]
    #[doc = ""]
    #[doc = " Topology flag ::HWLOC_TOPOLOGY_FLAG_IMPORT_SUPPORT may be used"]
    #[doc = " to report the supported features of the original remote machine"]
    #[doc = " instead. If it was successfully imported, \\p imported_support"]
    #[doc = " will be set in the struct hwloc_topology_misc_support array."]
    pub fn hwloc_topology_get_support(topology: hwloc_topology_t) -> *const hwloc_topology_support;
}
#[doc = " \\brief Keep all objects of this type."]
#[doc = ""]
#[doc = " Cannot be set for ::HWLOC_OBJ_GROUP (groups are designed only to add more structure to the topology)."]
#[doc = " \\hideinitializer"]
pub const hwloc_type_filter_e_HWLOC_TYPE_FILTER_KEEP_ALL: hwloc_type_filter_e = 0;
#[doc = " \\brief Ignore all objects of this type."]
#[doc = ""]
#[doc = " The bottom-level type ::HWLOC_OBJ_PU, the ::HWLOC_OBJ_NUMANODE type, and"]
#[doc = " the top-level type ::HWLOC_OBJ_MACHINE may not be ignored."]
#[doc = " \\hideinitializer"]
pub const hwloc_type_filter_e_HWLOC_TYPE_FILTER_KEEP_NONE: hwloc_type_filter_e = 1;
#[doc = " \\brief Only ignore objects if their entire level does not bring any structure."]
#[doc = ""]
#[doc = " Keep the entire level of objects if at least one of these objects adds"]
#[doc = " structure to the topology. An object brings structure when it has multiple"]
#[doc = " children and it is not the only child of its parent."]
#[doc = ""]
#[doc = " If all objects in the level are the only child of their parent, and if none"]
#[doc = " of them has multiple children, the entire level is removed."]
#[doc = ""]
#[doc = " Cannot be set for I/O and Misc objects since the topology structure does not matter there."]
#[doc = " \\hideinitializer"]
pub const hwloc_type_filter_e_HWLOC_TYPE_FILTER_KEEP_STRUCTURE: hwloc_type_filter_e = 2;
#[doc = " \\brief Only keep likely-important objects of the given type."]
#[doc = ""]
#[doc = " It is only useful for I/O object types."]
#[doc = " For ::HWLOC_OBJ_PCI_DEVICE and ::HWLOC_OBJ_OS_DEVICE, it means that only objects"]
#[doc = " of major/common kinds are kept (storage, network, OpenFabrics, CUDA,"]
#[doc = " OpenCL, RSMI, NVML, and displays)."]
#[doc = " Also, only OS devices directly attached on PCI (e.g. no USB) are reported."]
#[doc = " For ::HWLOC_OBJ_BRIDGE, it means that bridges are kept only if they have children."]
#[doc = ""]
#[doc = " This flag equivalent to ::HWLOC_TYPE_FILTER_KEEP_ALL for Normal, Memory and Misc types"]
#[doc = " since they are likely important."]
#[doc = " \\hideinitializer"]
pub const hwloc_type_filter_e_HWLOC_TYPE_FILTER_KEEP_IMPORTANT: hwloc_type_filter_e = 3;
#[doc = " \\brief Type filtering flags."]
#[doc = ""]
#[doc = " By default, most objects are kept (::HWLOC_TYPE_FILTER_KEEP_ALL)."]
#[doc = " Instruction caches, I/O and Misc objects are ignored by default (::HWLOC_TYPE_FILTER_KEEP_NONE)."]
#[doc = " Die and Group levels are ignored unless they bring structure (::HWLOC_TYPE_FILTER_KEEP_STRUCTURE)."]
#[doc = ""]
#[doc = " Note that group objects are also ignored individually (without the entire level)"]
#[doc = " when they do not bring structure."]
pub type hwloc_type_filter_e = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " \\brief Set the filtering for the given object type."]
    pub fn hwloc_topology_set_type_filter(
        topology: hwloc_topology_t,
        type_: hwloc_obj_type_t,
        filter: hwloc_type_filter_e,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get the current filtering for the given object type."]
    pub fn hwloc_topology_get_type_filter(
        topology: hwloc_topology_t,
        type_: hwloc_obj_type_t,
        filter: *mut hwloc_type_filter_e,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Set the filtering for all object types."]
    #[doc = ""]
    #[doc = " If some types do not support this filtering, they are silently ignored."]
    pub fn hwloc_topology_set_all_types_filter(
        topology: hwloc_topology_t,
        filter: hwloc_type_filter_e,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Set the filtering for all CPU cache object types."]
    #[doc = ""]
    #[doc = " Memory-side caches are not involved since they are not CPU caches."]
    pub fn hwloc_topology_set_cache_types_filter(
        topology: hwloc_topology_t,
        filter: hwloc_type_filter_e,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Set the filtering for all CPU instruction cache object types."]
    #[doc = ""]
    #[doc = " Memory-side caches are not involved since they are not CPU caches."]
    pub fn hwloc_topology_set_icache_types_filter(
        topology: hwloc_topology_t,
        filter: hwloc_type_filter_e,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Set the filtering for all I/O object types."]
    pub fn hwloc_topology_set_io_types_filter(
        topology: hwloc_topology_t,
        filter: hwloc_type_filter_e,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Set the topology-specific userdata pointer."]
    #[doc = ""]
    #[doc = " Each topology may store one application-given private data pointer."]
    #[doc = " It is initialized to \\c NULL."]
    #[doc = " hwloc will never modify it."]
    #[doc = ""]
    #[doc = " Use it as you wish, after hwloc_topology_init() and until hwloc_topolog_destroy()."]
    #[doc = ""]
    #[doc = " This pointer is not exported to XML."]
    pub fn hwloc_topology_set_userdata(
        topology: hwloc_topology_t,
        userdata: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " \\brief Retrieve the topology-specific userdata pointer."]
    #[doc = ""]
    #[doc = " Retrieve the application-given private data pointer that was"]
    #[doc = " previously set with hwloc_topology_set_userdata()."]
    pub fn hwloc_topology_get_userdata(topology: hwloc_topology_t) -> *mut ::std::os::raw::c_void;
}
#[doc = " \\brief Remove all objects that became CPU-less."]
#[doc = " By default, only objects that contain no PU and no memory are removed."]
#[doc = " This flag may not be used with ::HWLOC_RESTRICT_FLAG_BYNODESET."]
#[doc = " \\hideinitializer"]
pub const hwloc_restrict_flags_e_HWLOC_RESTRICT_FLAG_REMOVE_CPULESS: hwloc_restrict_flags_e = 1;
#[doc = " \\brief Restrict by nodeset instead of CPU set."]
#[doc = " Only keep objects whose nodeset is included or partially included in the given set."]
#[doc = " This flag may not be used with ::HWLOC_RESTRICT_FLAG_REMOVE_CPULESS."]
pub const hwloc_restrict_flags_e_HWLOC_RESTRICT_FLAG_BYNODESET: hwloc_restrict_flags_e = 8;
#[doc = " \\brief Remove all objects that became Memory-less."]
#[doc = " By default, only objects that contain no PU and no memory are removed."]
#[doc = " This flag may only be used with ::HWLOC_RESTRICT_FLAG_BYNODESET."]
#[doc = " \\hideinitializer"]
pub const hwloc_restrict_flags_e_HWLOC_RESTRICT_FLAG_REMOVE_MEMLESS: hwloc_restrict_flags_e = 16;
#[doc = " \\brief Move Misc objects to ancestors if their parents are removed during restriction."]
#[doc = " If this flag is not set, Misc objects are removed when their parents are removed."]
#[doc = " \\hideinitializer"]
pub const hwloc_restrict_flags_e_HWLOC_RESTRICT_FLAG_ADAPT_MISC: hwloc_restrict_flags_e = 2;
#[doc = " \\brief Move I/O objects to ancestors if their parents are removed during restriction."]
#[doc = " If this flag is not set, I/O devices and bridges are removed when their parents are removed."]
#[doc = " \\hideinitializer"]
pub const hwloc_restrict_flags_e_HWLOC_RESTRICT_FLAG_ADAPT_IO: hwloc_restrict_flags_e = 4;
#[doc = " \\brief Flags to be given to hwloc_topology_restrict()."]
pub type hwloc_restrict_flags_e = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " \\brief Restrict the topology to the given CPU set or nodeset."]
    #[doc = ""]
    #[doc = " Topology \\p topology is modified so as to remove all objects that"]
    #[doc = " are not included (or partially included) in the CPU set \\p set."]
    #[doc = " All objects CPU and node sets are restricted accordingly."]
    #[doc = ""]
    #[doc = " If ::HWLOC_RESTRICT_FLAG_BYNODESET is passed in \\p flags,"]
    #[doc = " \\p set is considered a nodeset instead of a CPU set."]
    #[doc = ""]
    #[doc = " \\p flags is a OR'ed set of ::hwloc_restrict_flags_e."]
    #[doc = ""]
    #[doc = " \\note This call may not be reverted by restricting back to a larger"]
    #[doc = " set. Once dropped during restriction, objects may not be brought"]
    #[doc = " back, except by loading another topology with hwloc_topology_load()."]
    #[doc = ""]
    #[doc = " \\return 0 on success."]
    #[doc = ""]
    #[doc = " \\return -1 with errno set to EINVAL if the input set is invalid."]
    #[doc = " The topology is not modified in this case."]
    #[doc = ""]
    #[doc = " \\return -1 with errno set to ENOMEM on failure to allocate internal data."]
    #[doc = " The topology is reinitialized in this case. It should be either"]
    #[doc = " destroyed with hwloc_topology_destroy() or configured and loaded again."]
    pub fn hwloc_topology_restrict(
        topology: hwloc_topology_t,
        set: hwloc_const_bitmap_t,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
#[doc = " \\brief Mark all objects as allowed in the topology."]
#[doc = ""]
#[doc = " \\p cpuset and \\p nođeset given to hwloc_topology_allow() must be \\c NULL."]
#[doc = " \\hideinitializer"]
pub const hwloc_allow_flags_e_HWLOC_ALLOW_FLAG_ALL: hwloc_allow_flags_e = 1;
#[doc = " \\brief Only allow objects that are available to the current process."]
#[doc = ""]
#[doc = " The topology must have ::HWLOC_TOPOLOGY_FLAG_IS_THISSYSTEM so that the set"]
#[doc = " of available resources can actually be retrieved from the operating system."]
#[doc = ""]
#[doc = " \\p cpuset and \\p nođeset given to hwloc_topology_allow() must be \\c NULL."]
#[doc = " \\hideinitializer"]
pub const hwloc_allow_flags_e_HWLOC_ALLOW_FLAG_LOCAL_RESTRICTIONS: hwloc_allow_flags_e = 2;
#[doc = " \\brief Allow a custom set of objects, given to hwloc_topology_allow() as \\p cpuset and/or \\p nodeset parameters."]
#[doc = " \\hideinitializer"]
pub const hwloc_allow_flags_e_HWLOC_ALLOW_FLAG_CUSTOM: hwloc_allow_flags_e = 4;
#[doc = " \\brief Flags to be given to hwloc_topology_allow()."]
pub type hwloc_allow_flags_e = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " \\brief Change the sets of allowed PUs and NUMA nodes in the topology."]
    #[doc = ""]
    #[doc = " This function only works if the ::HWLOC_TOPOLOGY_FLAG_INCLUDE_DISALLOWED"]
    #[doc = " was set on the topology. It does not modify any object, it only changes"]
    #[doc = " the sets returned by hwloc_topology_get_allowed_cpuset() and"]
    #[doc = " hwloc_topology_get_allowed_nodeset()."]
    #[doc = ""]
    #[doc = " It is notably useful when importing a topology from another process"]
    #[doc = " running in a different Linux Cgroup."]
    #[doc = ""]
    #[doc = " \\p flags must be set to one flag among ::hwloc_allow_flags_e."]
    #[doc = ""]
    #[doc = " \\note Removing objects from a topology should rather be performed with"]
    #[doc = " hwloc_topology_restrict()."]
    pub fn hwloc_topology_allow(
        topology: hwloc_topology_t,
        cpuset: hwloc_const_cpuset_t,
        nodeset: hwloc_const_nodeset_t,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Add a MISC object as a leaf of the topology"]
    #[doc = ""]
    #[doc = " A new MISC object will be created and inserted into the topology at the"]
    #[doc = " position given by parent. It is appended to the list of existing Misc children,"]
    #[doc = " without ever adding any intermediate hierarchy level. This is useful for"]
    #[doc = " annotating the topology without actually changing the hierarchy."]
    #[doc = ""]
    #[doc = " \\p name is supposed to be unique across all Misc objects in the topology."]
    #[doc = " It will be duplicated to setup the new object attributes."]
    #[doc = ""]
    #[doc = " The new leaf object will not have any \\p cpuset."]
    #[doc = ""]
    #[doc = " \\return the newly-created object"]
    #[doc = ""]
    #[doc = " \\return \\c NULL on error."]
    #[doc = ""]
    #[doc = " \\return \\c NULL if Misc objects are filtered-out of the topology (::HWLOC_TYPE_FILTER_KEEP_NONE)."]
    #[doc = ""]
    #[doc = " \\note If \\p name contains some non-printable characters, they will"]
    #[doc = " be dropped when exporting to XML, see hwloc_topology_export_xml() in hwloc/export.h."]
    pub fn hwloc_topology_insert_misc_object(
        topology: hwloc_topology_t,
        parent: hwloc_obj_t,
        name: *const ::std::os::raw::c_char,
    ) -> hwloc_obj_t;
}
extern "C" {
    #[doc = " \\brief Allocate a Group object to insert later with hwloc_topology_insert_group_object()."]
    #[doc = ""]
    #[doc = " This function returns a new Group object."]
    #[doc = ""]
    #[doc = " The caller should (at least) initialize its sets before inserting"]
    #[doc = " the object in the topology. See hwloc_topology_insert_group_object()."]
    pub fn hwloc_topology_alloc_group_object(topology: hwloc_topology_t) -> hwloc_obj_t;
}
extern "C" {
    #[doc = " \\brief Add more structure to the topology by adding an intermediate Group"]
    #[doc = ""]
    #[doc = " The caller should first allocate a new Group object with hwloc_topology_alloc_group_object()."]
    #[doc = " Then it must setup at least one of its CPU or node sets to specify"]
    #[doc = " the final location of the Group in the topology."]
    #[doc = " Then the object can be passed to this function for actual insertion in the topology."]
    #[doc = ""]
    #[doc = " Either the cpuset or nodeset field (or both, if compatible) must be set"]
    #[doc = " to a non-empty bitmap. The complete_cpuset or complete_nodeset may be set"]
    #[doc = " instead if inserting with respect to the complete topology"]
    #[doc = " (including disallowed, offline or unknown objects)."]
    #[doc = " If grouping several objects, hwloc_obj_add_other_obj_sets() is an easy way"]
    #[doc = " to build the Group sets iteratively."]
    #[doc = " These sets cannot be larger than the current topology, or they would get"]
    #[doc = " restricted silently."]
    #[doc = " The core will setup the other sets after actual insertion."]
    #[doc = ""]
    #[doc = " The \\p subtype object attribute may be defined (to a dynamically"]
    #[doc = " allocated string) to display something else than \"Group\" as the"]
    #[doc = " type name for this object in lstopo."]
    #[doc = " Custom name/value info pairs may be added with hwloc_obj_add_info() after"]
    #[doc = " insertion."]
    #[doc = ""]
    #[doc = " The group \\p dont_merge attribute may be set to \\c 1 to prevent"]
    #[doc = " the hwloc core from ever merging this object with another"]
    #[doc = " hierarchically-identical object."]
    #[doc = " This is useful when the Group itself describes an important feature"]
    #[doc = " that cannot be exposed anywhere else in the hierarchy."]
    #[doc = ""]
    #[doc = " The group \\p kind attribute may be set to a high value such"]
    #[doc = " as \\c 0xffffffff to tell hwloc that this new Group should always"]
    #[doc = " be discarded in favor of any existing Group with the same locality."]
    #[doc = ""]
    #[doc = " \\return The inserted object if it was properly inserted."]
    #[doc = ""]
    #[doc = " \\return An existing object if the Group was merged or discarded"]
    #[doc = " because the topology already contained an object at the same"]
    #[doc = " location (the Group did not add any hierarchy information)."]
    #[doc = ""]
    #[doc = " \\return \\c NULL if the insertion failed because of conflicting sets in topology tree."]
    #[doc = ""]
    #[doc = " \\return \\c NULL if Group objects are filtered-out of the topology (::HWLOC_TYPE_FILTER_KEEP_NONE)."]
    #[doc = ""]
    #[doc = " \\return \\c NULL if the object was discarded because no set was"]
    #[doc = " initialized in the Group before insert, or all of them were empty."]
    pub fn hwloc_topology_insert_group_object(
        topology: hwloc_topology_t,
        group: hwloc_obj_t,
    ) -> hwloc_obj_t;
}
extern "C" {
    #[doc = " \\brief Setup object cpusets/nodesets by OR'ing another object's sets."]
    #[doc = ""]
    #[doc = " For each defined cpuset or nodeset in \\p src, allocate the corresponding set"]
    #[doc = " in \\p dst and add \\p src to it by OR'ing sets."]
    #[doc = ""]
    #[doc = " This function is convenient between hwloc_topology_alloc_group_object()"]
    #[doc = " and hwloc_topology_insert_group_object(). It builds the sets of the new Group"]
    #[doc = " that will be inserted as a new intermediate parent of several objects."]
    pub fn hwloc_obj_add_other_obj_sets(
        dst: hwloc_obj_t,
        src: hwloc_obj_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Refresh internal structures after topology modification."]
    #[doc = ""]
    #[doc = " Modifying the topology (by restricting, adding objects, modifying structures"]
    #[doc = " such as distances or memory attributes, etc.) may cause some internal caches"]
    #[doc = " to become invalid. These caches are automatically refreshed when accessed"]
    #[doc = " but this refreshing is not thread-safe."]
    #[doc = ""]
    #[doc = " This function is not thread-safe either, but it is a good way to end a"]
    #[doc = " non-thread-safe phase of topology modification. Once this refresh is done,"]
    #[doc = " multiple threads may concurrently consult the topology, objects, distances,"]
    #[doc = " attributes, etc."]
    #[doc = ""]
    #[doc = " See also \\ref threadsafety"]
    pub fn hwloc_topology_refresh(topology: hwloc_topology_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get the set of largest objects covering exactly a given cpuset \\p set"]
    #[doc = ""]
    #[doc = " \\return the number of objects returned in \\p objs."]
    pub fn hwloc_get_largest_objs_inside_cpuset(
        topology: hwloc_topology_t,
        set: hwloc_const_cpuset_t,
        objs: *mut hwloc_obj_t,
        max: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Check whether an object type is Normal."]
    #[doc = ""]
    #[doc = " Normal objects are objects of the main CPU hierarchy"]
    #[doc = " (Machine, Package, Core, PU, CPU caches, etc.),"]
    #[doc = " but they are not NUMA nodes, I/O devices or Misc objects."]
    #[doc = ""]
    #[doc = " They are attached to parent as Normal children,"]
    #[doc = " not as Memory, I/O or Misc children."]
    #[doc = ""]
    #[doc = " \\return 1 if an object of type \\p type is a Normal object, 0 otherwise."]
    pub fn hwloc_obj_type_is_normal(type_: hwloc_obj_type_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Check whether an object type is I/O."]
    #[doc = ""]
    #[doc = " I/O objects are objects attached to their parents"]
    #[doc = " in the I/O children list."]
    #[doc = " This current includes Bridges, PCI and OS devices."]
    #[doc = ""]
    #[doc = " \\return 1 if an object of type \\p type is a I/O object, 0 otherwise."]
    pub fn hwloc_obj_type_is_io(type_: hwloc_obj_type_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Check whether an object type is Memory."]
    #[doc = ""]
    #[doc = " Memory objects are objects attached to their parents"]
    #[doc = " in the Memory children list."]
    #[doc = " This current includes NUMA nodes and Memory-side caches."]
    #[doc = ""]
    #[doc = " \\return 1 if an object of type \\p type is a Memory object, 0 otherwise."]
    pub fn hwloc_obj_type_is_memory(type_: hwloc_obj_type_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Check whether an object type is a CPU Cache (Data, Unified or Instruction)."]
    #[doc = ""]
    #[doc = " Memory-side caches are not CPU caches."]
    #[doc = ""]
    #[doc = " \\return 1 if an object of type \\p type is a Cache, 0 otherwise."]
    pub fn hwloc_obj_type_is_cache(type_: hwloc_obj_type_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Check whether an object type is a CPU Data or Unified Cache."]
    #[doc = ""]
    #[doc = " Memory-side caches are not CPU caches."]
    #[doc = ""]
    #[doc = " \\return 1 if an object of type \\p type is a CPU Data or Unified Cache, 0 otherwise."]
    pub fn hwloc_obj_type_is_dcache(type_: hwloc_obj_type_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Check whether an object type is a CPU Instruction Cache,"]
    #[doc = ""]
    #[doc = " Memory-side caches are not CPU caches."]
    #[doc = ""]
    #[doc = " \\return 1 if an object of type \\p type is a CPU Instruction Cache, 0 otherwise."]
    pub fn hwloc_obj_type_is_icache(type_: hwloc_obj_type_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Remove simultaneous multithreading PUs from a CPU set."]
    #[doc = ""]
    #[doc = " For each core in \\p topology, if \\p cpuset contains some PUs of that core,"]
    #[doc = " modify \\p cpuset to only keep a single PU for that core."]
    #[doc = ""]
    #[doc = " \\p which specifies which PU will be kept."]
    #[doc = " PU are considered in physical index order."]
    #[doc = " If 0, for each core, the function keeps the first PU that was originally set in \\p cpuset."]
    #[doc = ""]
    #[doc = " If \\p which is larger than the number of PUs in a core there were originally set in \\p cpuset,"]
    #[doc = " no PU is kept for that core."]
    #[doc = ""]
    #[doc = " \\note PUs that are not below a Core object are ignored"]
    #[doc = " (for instance if the topology does not contain any Core object)."]
    #[doc = " None of them is removed from \\p cpuset."]
    pub fn hwloc_bitmap_singlify_per_core(
        topology: hwloc_topology_t,
        cpuset: hwloc_bitmap_t,
        which: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Do a depth-first traversal of the topology to find and sort"]
    #[doc = ""]
    #[doc = " all objects that are at the same depth than \\p src."]
    #[doc = " Report in \\p objs up to \\p max physically closest ones to \\p src."]
    #[doc = ""]
    #[doc = " \\return the number of objects returned in \\p objs."]
    #[doc = ""]
    #[doc = " \\return 0 if \\p src is an I/O object."]
    #[doc = ""]
    #[doc = " \\note This function requires the \\p src object to have a CPU set."]
    pub fn hwloc_get_closest_objs(
        topology: hwloc_topology_t,
        src: hwloc_obj_t,
        objs: *mut hwloc_obj_t,
        max: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " \\brief Return an object of a different type with same locality."]
    #[doc = ""]
    #[doc = " If the source object \\p src is a normal or memory type,"]
    #[doc = " this function returns an object of type \\p type with same"]
    #[doc = " CPU and node sets, either below or above in the hierarchy."]
    #[doc = ""]
    #[doc = " If the source object \\p src is a PCI or an OS device within a PCI"]
    #[doc = " device, the function may either return that PCI device, or another"]
    #[doc = " OS device in the same PCI parent."]
    #[doc = " This may for instance be useful for converting between OS devices"]
    #[doc = " such as \"nvml0\" or \"rsmi1\" used in distance structures into the"]
    #[doc = " the PCI device, or the CUDA or OpenCL OS device that correspond"]
    #[doc = " to the same physical card."]
    #[doc = ""]
    #[doc = " If not \\c NULL, parameter \\p subtype only select objects whose"]
    #[doc = " subtype attribute exists and is \\p subtype (case-insensitively),"]
    #[doc = " for instance \"OpenCL\" or \"CUDA\"."]
    #[doc = ""]
    #[doc = " If not \\c NULL, parameter \\p nameprefix only selects objects whose"]
    #[doc = " name attribute exists and starts with \\p nameprefix (case-insensitively),"]
    #[doc = " for instance \"rsmi\" for matching \"rsmi0\"."]
    #[doc = ""]
    #[doc = " If multiple objects match, the first one is returned."]
    #[doc = ""]
    #[doc = " This function will not walk the hierarchy across bridges since"]
    #[doc = " the PCI locality may become different."]
    #[doc = " This function cannot also convert between normal/memory objects"]
    #[doc = " and I/O or Misc objects."]
    #[doc = ""]
    #[doc = " \\p flags must be \\c 0 for now."]
    #[doc = ""]
    #[doc = " \\return An object with identical locality,"]
    #[doc = " matching \\p subtype and \\p nameprefix if any."]
    #[doc = ""]
    #[doc = " \\return \\c NULL if no matching object could be found,"]
    #[doc = " or if the source object and target type are incompatible,"]
    #[doc = " for instance if converting between CPU and I/O objects."]
    pub fn hwloc_get_obj_with_same_locality(
        topology: hwloc_topology_t,
        src: hwloc_obj_t,
        type_: hwloc_obj_type_t,
        subtype: *const ::std::os::raw::c_char,
        nameprefix: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_ulong,
    ) -> hwloc_obj_t;
}
#[doc = " \\brief Distrib in reverse order, starting from the last objects."]
#[doc = " \\hideinitializer"]
pub const hwloc_distrib_flags_e_HWLOC_DISTRIB_FLAG_REVERSE: hwloc_distrib_flags_e = 1;
#[doc = " \\brief Flags to be given to hwloc_distrib()."]
pub type hwloc_distrib_flags_e = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " \\brief Get complete CPU set"]
    #[doc = ""]
    #[doc = " \\return the complete CPU set of processors of the system."]
    #[doc = ""]
    #[doc = " \\note The returned cpuset is not newly allocated and should thus not be"]
    #[doc = " changed or freed; hwloc_bitmap_dup() must be used to obtain a local copy."]
    #[doc = ""]
    #[doc = " \\note This is equivalent to retrieving the root object complete CPU-set."]
    pub fn hwloc_topology_get_complete_cpuset(topology: hwloc_topology_t) -> hwloc_const_cpuset_t;
}
extern "C" {
    #[doc = " \\brief Get topology CPU set"]
    #[doc = ""]
    #[doc = " \\return the CPU set of processors of the system for which hwloc"]
    #[doc = " provides topology information. This is equivalent to the cpuset of the"]
    #[doc = " system object."]
    #[doc = ""]
    #[doc = " \\note The returned cpuset is not newly allocated and should thus not be"]
    #[doc = " changed or freed; hwloc_bitmap_dup() must be used to obtain a local copy."]
    #[doc = ""]
    #[doc = " \\note This is equivalent to retrieving the root object CPU-set."]
    pub fn hwloc_topology_get_topology_cpuset(topology: hwloc_topology_t) -> hwloc_const_cpuset_t;
}
extern "C" {
    #[doc = " \\brief Get allowed CPU set"]
    #[doc = ""]
    #[doc = " \\return the CPU set of allowed processors of the system."]
    #[doc = ""]
    #[doc = " \\note If the topology flag ::HWLOC_TOPOLOGY_FLAG_INCLUDE_DISALLOWED was not set,"]
    #[doc = " this is identical to hwloc_topology_get_topology_cpuset(), which means"]
    #[doc = " all PUs are allowed."]
    #[doc = ""]
    #[doc = " \\note If ::HWLOC_TOPOLOGY_FLAG_INCLUDE_DISALLOWED was set, applying"]
    #[doc = " hwloc_bitmap_intersects() on the result of this function and on an object"]
    #[doc = " cpuset checks whether there are allowed PUs inside that object."]
    #[doc = " Applying hwloc_bitmap_and() returns the list of these allowed PUs."]
    #[doc = ""]
    #[doc = " \\note The returned cpuset is not newly allocated and should thus not be"]
    #[doc = " changed or freed, hwloc_bitmap_dup() must be used to obtain a local copy."]
    pub fn hwloc_topology_get_allowed_cpuset(topology: hwloc_topology_t) -> hwloc_const_cpuset_t;
}
extern "C" {
    #[doc = " \\brief Get complete node set"]
    #[doc = ""]
    #[doc = " \\return the complete node set of memory of the system."]
    #[doc = ""]
    #[doc = " \\note The returned nodeset is not newly allocated and should thus not be"]
    #[doc = " changed or freed; hwloc_bitmap_dup() must be used to obtain a local copy."]
    #[doc = ""]
    #[doc = " \\note This is equivalent to retrieving the root object complete nodeset."]
    pub fn hwloc_topology_get_complete_nodeset(topology: hwloc_topology_t)
        -> hwloc_const_nodeset_t;
}
extern "C" {
    #[doc = " \\brief Get topology node set"]
    #[doc = ""]
    #[doc = " \\return the node set of memory of the system for which hwloc"]
    #[doc = " provides topology information. This is equivalent to the nodeset of the"]
    #[doc = " system object."]
    #[doc = ""]
    #[doc = " \\note The returned nodeset is not newly allocated and should thus not be"]
    #[doc = " changed or freed; hwloc_bitmap_dup() must be used to obtain a local copy."]
    #[doc = ""]
    #[doc = " \\note This is equivalent to retrieving the root object nodeset."]
    pub fn hwloc_topology_get_topology_nodeset(topology: hwloc_topology_t)
        -> hwloc_const_nodeset_t;
}
extern "C" {
    #[doc = " \\brief Get allowed node set"]
    #[doc = ""]
    #[doc = " \\return the node set of allowed memory of the system."]
    #[doc = ""]
    #[doc = " \\note If the topology flag ::HWLOC_TOPOLOGY_FLAG_INCLUDE_DISALLOWED was not set,"]
    #[doc = " this is identical to hwloc_topology_get_topology_nodeset(), which means"]
    #[doc = " all NUMA nodes are allowed."]
    #[doc = ""]
    #[doc = " \\note If ::HWLOC_TOPOLOGY_FLAG_INCLUDE_DISALLOWED was set, applying"]
    #[doc = " hwloc_bitmap_intersects() on the result of this function and on an object"]
    #[doc = " nodeset checks whether there are allowed NUMA nodes inside that object."]
    #[doc = " Applying hwloc_bitmap_and() returns the list of these allowed NUMA nodes."]
    #[doc = ""]
    #[doc = " \\note The returned nodeset is not newly allocated and should thus not be"]
    #[doc = " changed or freed, hwloc_bitmap_dup() must be used to obtain a local copy."]
    pub fn hwloc_topology_get_allowed_nodeset(topology: hwloc_topology_t) -> hwloc_const_nodeset_t;
}
#[doc = " \\brief \"Capacity\"."]
#[doc = " The capacity is returned in bytes"]
#[doc = " (local_memory attribute in objects)."]
#[doc = ""]
#[doc = " Best capacity nodes are nodes with <b>higher capacity</b>."]
#[doc = ""]
#[doc = " No initiator is involved when looking at this attribute."]
#[doc = " The corresponding attribute flags are ::HWLOC_MEMATTR_FLAG_HIGHER_FIRST."]
pub const hwloc_memattr_id_e_HWLOC_MEMATTR_ID_CAPACITY: hwloc_memattr_id_e = 0;
#[doc = " \\brief \"Locality\"."]
#[doc = " The locality is returned as the number of PUs in that locality"]
#[doc = " (e.g. the weight of its cpuset)."]
#[doc = ""]
#[doc = " Best locality nodes are nodes with <b>smaller locality</b>"]
#[doc = " (nodes that are local to very few PUs)."]
#[doc = " Poor locality nodes are nodes with larger locality"]
#[doc = " (nodes that are local to the entire machine)."]
#[doc = ""]
#[doc = " No initiator is involved when looking at this attribute."]
#[doc = " The corresponding attribute flags are ::HWLOC_MEMATTR_FLAG_HIGHER_FIRST."]
pub const hwloc_memattr_id_e_HWLOC_MEMATTR_ID_LOCALITY: hwloc_memattr_id_e = 1;
#[doc = " \\brief \"Bandwidth\"."]
#[doc = " The bandwidth is returned in MiB/s, as seen from the given initiator location."]
#[doc = " Best bandwidth nodes are nodes with <b>higher bandwidth</b>."]
#[doc = " The corresponding attribute flags are ::HWLOC_MEMATTR_FLAG_HIGHER_FIRST"]
#[doc = " and ::HWLOC_MEMATTR_FLAG_NEED_INITIATOR."]
pub const hwloc_memattr_id_e_HWLOC_MEMATTR_ID_BANDWIDTH: hwloc_memattr_id_e = 2;
#[doc = " \\brief \"Latency\"."]
#[doc = " The latency is returned as nanoseconds, as seen from the given initiator location."]
#[doc = " Best latency nodes are nodes with <b>smaller latency</b>."]
#[doc = " The corresponding attribute flags are ::HWLOC_MEMATTR_FLAG_LOWER_FIRST"]
#[doc = " and ::HWLOC_MEMATTR_FLAG_NEED_INITIATOR."]
pub const hwloc_memattr_id_e_HWLOC_MEMATTR_ID_LATENCY: hwloc_memattr_id_e = 3;
#[doc = " \\brief Memory node attributes."]
pub type hwloc_memattr_id_e = ::std::os::raw::c_uint;
#[doc = " \\brief A memory attribute identifier."]
#[doc = " May be either one of ::hwloc_memattr_id_e or a new id returned by hwloc_memattr_register()."]
pub type hwloc_memattr_id_t = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " \\brief Return the identifier of the memory attribute with the given name."]
    pub fn hwloc_memattr_get_by_name(
        topology: hwloc_topology_t,
        name: *const ::std::os::raw::c_char,
        id: *mut hwloc_memattr_id_t,
    ) -> ::std::os::raw::c_int;
}
#[doc = " \\brief Location is given as a cpuset, in the location cpuset union field. \\hideinitializer"]
pub const hwloc_location_type_e_HWLOC_LOCATION_TYPE_CPUSET: hwloc_location_type_e = 1;
#[doc = " \\brief Location is given as an object, in the location object union field. \\hideinitializer"]
pub const hwloc_location_type_e_HWLOC_LOCATION_TYPE_OBJECT: hwloc_location_type_e = 0;
#[doc = " \\brief Type of location."]
pub type hwloc_location_type_e = ::std::os::raw::c_uint;
#[doc = " \\brief Where to measure attributes from."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hwloc_location {
    #[doc = " \\brief Type of location."]
    pub type_: hwloc_location_type_e,
    pub location: hwloc_location_hwloc_location_u,
}
#[doc = " \\brief Actual location."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union hwloc_location_hwloc_location_u {
    #[doc = " \\brief Location as a cpuset, when the location type is ::HWLOC_LOCATION_TYPE_CPUSET."]
    pub cpuset: hwloc_cpuset_t,
    #[doc = " \\brief Location as an object, when the location type is ::HWLOC_LOCATION_TYPE_OBJECT."]
    pub object: hwloc_obj_t,
}
#[test]
fn bindgen_test_layout_hwloc_location_hwloc_location_u() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_location_hwloc_location_u>(),
        8usize,
        concat!("Size of: ", stringify!(hwloc_location_hwloc_location_u))
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_location_hwloc_location_u>(),
        8usize,
        concat!("Alignment of ", stringify!(hwloc_location_hwloc_location_u))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_location_hwloc_location_u>())).cpuset as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_location_hwloc_location_u),
            "::",
            stringify!(cpuset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_location_hwloc_location_u>())).object as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_location_hwloc_location_u),
            "::",
            stringify!(object)
        )
    );
}
#[test]
fn bindgen_test_layout_hwloc_location() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_location>(),
        16usize,
        concat!("Size of: ", stringify!(hwloc_location))
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_location>(),
        8usize,
        concat!("Alignment of ", stringify!(hwloc_location))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_location>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_location),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_location>())).location as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_location),
            "::",
            stringify!(location)
        )
    );
}
#[doc = " \\brief Select NUMA nodes whose locality is larger than the given cpuset."]
#[doc = " For instance, if a single PU (or its cpuset) is given in \\p initiator,"]
#[doc = " select all nodes close to the package that contains this PU."]
#[doc = " \\hideinitializer"]
pub const hwloc_local_numanode_flag_e_HWLOC_LOCAL_NUMANODE_FLAG_LARGER_LOCALITY:
    hwloc_local_numanode_flag_e = 1;
#[doc = " \\brief Select NUMA nodes whose locality is smaller than the given cpuset."]
#[doc = " For instance, if a package (or its cpuset) is given in \\p initiator,"]
#[doc = " also select nodes that are attached to only a half of that package."]
#[doc = " \\hideinitializer"]
pub const hwloc_local_numanode_flag_e_HWLOC_LOCAL_NUMANODE_FLAG_SMALLER_LOCALITY:
    hwloc_local_numanode_flag_e = 2;
#[doc = " \\brief Select all NUMA nodes in the topology."]
#[doc = " The initiator \\p initiator is ignored."]
#[doc = " \\hideinitializer"]
pub const hwloc_local_numanode_flag_e_HWLOC_LOCAL_NUMANODE_FLAG_ALL: hwloc_local_numanode_flag_e =
    4;
#[doc = " \\brief Flags for selecting target NUMA nodes."]
pub type hwloc_local_numanode_flag_e = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " \\brief Return an array of local NUMA nodes."]
    #[doc = ""]
    #[doc = " By default only select the NUMA nodes whose locality is exactly"]
    #[doc = " the given \\p location. More nodes may be selected if additional flags"]
    #[doc = " are given as a OR'ed set of ::hwloc_local_numanode_flag_e."]
    #[doc = ""]
    #[doc = " If \\p location is given as an explicit object, its CPU set is used"]
    #[doc = " to find NUMA nodes with the corresponding locality."]
    #[doc = " If the object does not have a CPU set (e.g. I/O object), the CPU"]
    #[doc = " parent (where the I/O object is attached) is used."]
    #[doc = ""]
    #[doc = " On input, \\p nr points to the number of nodes that may be stored"]
    #[doc = " in the \\p nodes array."]
    #[doc = " On output, \\p nr will be changed to the number of stored nodes,"]
    #[doc = " or the number of nodes that would have been stored if there were"]
    #[doc = " enough room."]
    #[doc = ""]
    #[doc = " \\note Some of these NUMA nodes may not have any memory attribute"]
    #[doc = " values and hence not be reported as actual targets in other functions."]
    #[doc = ""]
    #[doc = " \\note The number of NUMA nodes in the topology (obtained by"]
    #[doc = " hwloc_bitmap_weight() on the root object nodeset) may be used"]
    #[doc = " to allocate the \\p nodes array."]
    #[doc = ""]
    #[doc = " \\note When an object CPU set is given as locality, for instance a Package,"]
    #[doc = " and when flags contain both ::HWLOC_LOCAL_NUMANODE_FLAG_LARGER_LOCALITY"]
    #[doc = " and ::HWLOC_LOCAL_NUMANODE_FLAG_SMALLER_LOCALITY,"]
    #[doc = " the returned array corresponds to the nodeset of that object."]
    pub fn hwloc_get_local_numanode_objs(
        topology: hwloc_topology_t,
        location: *mut hwloc_location,
        nr: *mut ::std::os::raw::c_uint,
        nodes: *mut hwloc_obj_t,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Return an attribute value for a specific target NUMA node."]
    #[doc = ""]
    #[doc = " If the attribute does not relate to a specific initiator"]
    #[doc = " (it does not have the flag ::HWLOC_MEMATTR_FLAG_NEED_INITIATOR),"]
    #[doc = " location \\p initiator is ignored and may be \\c NULL."]
    #[doc = ""]
    #[doc = " \\p flags must be \\c 0 for now."]
    #[doc = ""]
    #[doc = " \\note The initiator \\p initiator should be of type ::HWLOC_LOCATION_TYPE_CPUSET"]
    #[doc = " when refering to accesses performed by CPU cores."]
    #[doc = " ::HWLOC_LOCATION_TYPE_OBJECT is currently unused internally by hwloc,"]
    #[doc = " but users may for instance use it to provide custom information about"]
    #[doc = " host memory accesses performed by GPUs."]
    pub fn hwloc_memattr_get_value(
        topology: hwloc_topology_t,
        attribute: hwloc_memattr_id_t,
        target_node: hwloc_obj_t,
        initiator: *mut hwloc_location,
        flags: ::std::os::raw::c_ulong,
        value: *mut hwloc_uint64_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Return the best target NUMA node for the given attribute and initiator."]
    #[doc = ""]
    #[doc = " If the attribute does not relate to a specific initiator"]
    #[doc = " (it does not have the flag ::HWLOC_MEMATTR_FLAG_NEED_INITIATOR),"]
    #[doc = " location \\p initiator is ignored and may be \\c NULL."]
    #[doc = ""]
    #[doc = " If \\p value is non \\c NULL, the corresponding value is returned there."]
    #[doc = ""]
    #[doc = " If multiple targets have the same attribute values, only one is"]
    #[doc = " returned (and there is no way to clarify how that one is chosen)."]
    #[doc = " Applications that want to detect targets with identical/similar"]
    #[doc = " values, or that want to look at values for multiple attributes,"]
    #[doc = " should rather get all values using hwloc_memattr_get_value()"]
    #[doc = " and manually select the target they consider the best."]
    #[doc = ""]
    #[doc = " \\p flags must be \\c 0 for now."]
    #[doc = ""]
    #[doc = " If there are no matching targets, \\c -1 is returned with \\p errno set to \\c ENOENT;"]
    #[doc = ""]
    #[doc = " \\note The initiator \\p initiator should be of type ::HWLOC_LOCATION_TYPE_CPUSET"]
    #[doc = " when refering to accesses performed by CPU cores."]
    #[doc = " ::HWLOC_LOCATION_TYPE_OBJECT is currently unused internally by hwloc,"]
    #[doc = " but users may for instance use it to provide custom information about"]
    #[doc = " host memory accesses performed by GPUs."]
    pub fn hwloc_memattr_get_best_target(
        topology: hwloc_topology_t,
        attribute: hwloc_memattr_id_t,
        initiator: *mut hwloc_location,
        flags: ::std::os::raw::c_ulong,
        best_target: *mut hwloc_obj_t,
        value: *mut hwloc_uint64_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Return the best initiator for the given attribute and target NUMA node."]
    #[doc = ""]
    #[doc = " If the attribute does not relate to a specific initiator"]
    #[doc = " (it does not have the flag ::HWLOC_MEMATTR_FLAG_NEED_INITIATOR),"]
    #[doc = " \\c -1 is returned and \\p errno is set to \\c EINVAL."]
    #[doc = ""]
    #[doc = " If \\p value is non \\c NULL, the corresponding value is returned there."]
    #[doc = ""]
    #[doc = " If multiple initiators have the same attribute values, only one is"]
    #[doc = " returned (and there is no way to clarify how that one is chosen)."]
    #[doc = " Applications that want to detect initiators with identical/similar"]
    #[doc = " values, or that want to look at values for multiple attributes,"]
    #[doc = " should rather get all values using hwloc_memattr_get_value()"]
    #[doc = " and manually select the initiator they consider the best."]
    #[doc = ""]
    #[doc = " The returned initiator should not be modified or freed,"]
    #[doc = " it belongs to the topology."]
    #[doc = ""]
    #[doc = " \\p flags must be \\c 0 for now."]
    #[doc = ""]
    #[doc = " If there are no matching initiators, \\c -1 is returned with \\p errno set to \\c ENOENT;"]
    pub fn hwloc_memattr_get_best_initiator(
        topology: hwloc_topology_t,
        attribute: hwloc_memattr_id_t,
        target: hwloc_obj_t,
        flags: ::std::os::raw::c_ulong,
        best_initiator: *mut hwloc_location,
        value: *mut hwloc_uint64_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Return the name of a memory attribute."]
    pub fn hwloc_memattr_get_name(
        topology: hwloc_topology_t,
        attribute: hwloc_memattr_id_t,
        name: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Return the flags of the given attribute."]
    #[doc = ""]
    #[doc = " Flags are a OR'ed set of ::hwloc_memattr_flag_e."]
    pub fn hwloc_memattr_get_flags(
        topology: hwloc_topology_t,
        attribute: hwloc_memattr_id_t,
        flags: *mut ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
#[doc = " \\brief The best nodes for this memory attribute are those with the higher values."]
#[doc = " For instance Bandwidth."]
pub const hwloc_memattr_flag_e_HWLOC_MEMATTR_FLAG_HIGHER_FIRST: hwloc_memattr_flag_e = 1;
#[doc = " \\brief The best nodes for this memory attribute are those with the lower values."]
#[doc = " For instance Latency."]
pub const hwloc_memattr_flag_e_HWLOC_MEMATTR_FLAG_LOWER_FIRST: hwloc_memattr_flag_e = 2;
#[doc = " \\brief The value returned for this memory attribute depends on the given initiator."]
#[doc = " For instance Bandwidth and Latency, but not Capacity."]
pub const hwloc_memattr_flag_e_HWLOC_MEMATTR_FLAG_NEED_INITIATOR: hwloc_memattr_flag_e = 4;
#[doc = " \\brief Memory attribute flags."]
#[doc = " Given to hwloc_memattr_register() and returned by hwloc_memattr_get_flags()."]
pub type hwloc_memattr_flag_e = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " \\brief Register a new memory attribute."]
    #[doc = ""]
    #[doc = " Add a specific memory attribute that is not defined in ::hwloc_memattr_id_e."]
    #[doc = " Flags are a OR'ed set of ::hwloc_memattr_flag_e. It must contain at least"]
    #[doc = " one of ::HWLOC_MEMATTR_FLAG_HIGHER_FIRST or ::HWLOC_MEMATTR_FLAG_LOWER_FIRST."]
    pub fn hwloc_memattr_register(
        topology: hwloc_topology_t,
        name: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_ulong,
        id: *mut hwloc_memattr_id_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Set an attribute value for a specific target NUMA node."]
    #[doc = ""]
    #[doc = " If the attribute does not relate to a specific initiator"]
    #[doc = " (it does not have the flag ::HWLOC_MEMATTR_FLAG_NEED_INITIATOR),"]
    #[doc = " location \\p initiator is ignored and may be \\c NULL."]
    #[doc = ""]
    #[doc = " The initiator will be copied into the topology,"]
    #[doc = " the caller should free anything allocated to store the initiator,"]
    #[doc = " for instance the cpuset."]
    #[doc = ""]
    #[doc = " \\p flags must be \\c 0 for now."]
    #[doc = ""]
    #[doc = " \\note The initiator \\p initiator should be of type ::HWLOC_LOCATION_TYPE_CPUSET"]
    #[doc = " when referring to accesses performed by CPU cores."]
    #[doc = " ::HWLOC_LOCATION_TYPE_OBJECT is currently unused internally by hwloc,"]
    #[doc = " but users may for instance use it to provide custom information about"]
    #[doc = " host memory accesses performed by GPUs."]
    pub fn hwloc_memattr_set_value(
        topology: hwloc_topology_t,
        attribute: hwloc_memattr_id_t,
        target_node: hwloc_obj_t,
        initiator: *mut hwloc_location,
        flags: ::std::os::raw::c_ulong,
        value: hwloc_uint64_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Return the target NUMA nodes that have some values for a given attribute."]
    #[doc = ""]
    #[doc = " Return targets for the given attribute in the \\p targets array"]
    #[doc = " (for the given initiator if any)."]
    #[doc = " If \\p values is not \\c NULL, the corresponding attribute values"]
    #[doc = " are stored in the array it points to."]
    #[doc = ""]
    #[doc = " On input, \\p nr points to the number of targets that may be stored"]
    #[doc = " in the array \\p targets (and \\p values)."]
    #[doc = " On output, \\p nr points to the number of targets (and values) that"]
    #[doc = " were actually found, even if some of them couldn't be stored in the array."]
    #[doc = " Targets that couldn't be stored are ignored, but the function still"]
    #[doc = " returns success (\\c 0). The caller may find out by comparing the value pointed"]
    #[doc = " by \\p nr before and after the function call."]
    #[doc = ""]
    #[doc = " The returned targets should not be modified or freed,"]
    #[doc = " they belong to the topology."]
    #[doc = ""]
    #[doc = " Argument \\p initiator is ignored if the attribute does not relate to a specific"]
    #[doc = " initiator (it does not have the flag ::HWLOC_MEMATTR_FLAG_NEED_INITIATOR)."]
    #[doc = " Otherwise \\p initiator may be non \\c NULL to report only targets"]
    #[doc = " that have a value for that initiator."]
    #[doc = ""]
    #[doc = " \\p flags must be \\c 0 for now."]
    #[doc = ""]
    #[doc = " \\note This function is meant for tools and debugging (listing internal information)"]
    #[doc = " rather than for application queries. Applications should rather select useful"]
    #[doc = " NUMA nodes with hwloc_get_local_numanode_objs() and then look at their attribute"]
    #[doc = " values."]
    #[doc = ""]
    #[doc = " \\note The initiator \\p initiator should be of type ::HWLOC_LOCATION_TYPE_CPUSET"]
    #[doc = " when referring to accesses performed by CPU cores."]
    #[doc = " ::HWLOC_LOCATION_TYPE_OBJECT is currently unused internally by hwloc,"]
    #[doc = " but users may for instance use it to provide custom information about"]
    #[doc = " host memory accesses performed by GPUs."]
    pub fn hwloc_memattr_get_targets(
        topology: hwloc_topology_t,
        attribute: hwloc_memattr_id_t,
        initiator: *mut hwloc_location,
        flags: ::std::os::raw::c_ulong,
        nr: *mut ::std::os::raw::c_uint,
        targets: *mut hwloc_obj_t,
        values: *mut hwloc_uint64_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Return the initiators that have values for a given attribute for a specific target NUMA node."]
    #[doc = ""]
    #[doc = " Return initiators for the given attribute and target node in the"]
    #[doc = " \\p initiators array."]
    #[doc = " If \\p values is not \\c NULL, the corresponding attribute values"]
    #[doc = " are stored in the array it points to."]
    #[doc = ""]
    #[doc = " On input, \\p nr points to the number of initiators that may be stored"]
    #[doc = " in the array \\p initiators (and \\p values)."]
    #[doc = " On output, \\p nr points to the number of initiators (and values) that"]
    #[doc = " were actually found, even if some of them couldn't be stored in the array."]
    #[doc = " Initiators that couldn't be stored are ignored, but the function still"]
    #[doc = " returns success (\\c 0). The caller may find out by comparing the value pointed"]
    #[doc = " by \\p nr before and after the function call."]
    #[doc = ""]
    #[doc = " The returned initiators should not be modified or freed,"]
    #[doc = " they belong to the topology."]
    #[doc = ""]
    #[doc = " \\p flags must be \\c 0 for now."]
    #[doc = ""]
    #[doc = " If the attribute does not relate to a specific initiator"]
    #[doc = " (it does not have the flag ::HWLOC_MEMATTR_FLAG_NEED_INITIATOR),"]
    #[doc = " no initiator is returned."]
    #[doc = ""]
    #[doc = " \\note This function is meant for tools and debugging (listing internal information)"]
    #[doc = " rather than for application queries. Applications should rather select useful"]
    #[doc = " NUMA nodes with hwloc_get_local_numanode_objs() and then look at their attribute"]
    #[doc = " values for some relevant initiators."]
    pub fn hwloc_memattr_get_initiators(
        topology: hwloc_topology_t,
        attribute: hwloc_memattr_id_t,
        target_node: hwloc_obj_t,
        flags: ::std::os::raw::c_ulong,
        nr: *mut ::std::os::raw::c_uint,
        initiators: *mut hwloc_location,
        values: *mut hwloc_uint64_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get the number of different kinds of CPU cores in the topology."]
    #[doc = ""]
    #[doc = " \\p flags must be \\c 0 for now."]
    #[doc = ""]
    #[doc = " \\return The number of CPU kinds (positive integer) on success."]
    #[doc = " \\return \\c 0 if no information about kinds was found."]
    #[doc = " \\return \\c -1 with \\p errno set to \\c EINVAL if \\p flags is invalid."]
    pub fn hwloc_cpukinds_get_nr(
        topology: hwloc_topology_t,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get the index of the CPU kind that contains CPUs listed in \\p cpuset."]
    #[doc = ""]
    #[doc = " \\p flags must be \\c 0 for now."]
    #[doc = ""]
    #[doc = " \\return The index of the CPU kind (positive integer or 0) on success."]
    #[doc = " \\return \\c -1 with \\p errno set to \\c EXDEV if \\p cpuset is"]
    #[doc = " only partially included in the some kind."]
    #[doc = " \\return \\c -1 with \\p errno set to \\c ENOENT if \\p cpuset is"]
    #[doc = " not included in any kind, even partially."]
    #[doc = " \\return \\c -1 with \\p errno set to \\c EINVAL if parameters are invalid."]
    pub fn hwloc_cpukinds_get_by_cpuset(
        topology: hwloc_topology_t,
        cpuset: hwloc_const_bitmap_t,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get the CPU set and infos about a CPU kind in the topology."]
    #[doc = ""]
    #[doc = " \\p kind_index identifies one kind of CPU between 0 and the number"]
    #[doc = " of kinds returned by hwloc_cpukinds_get_nr() minus 1."]
    #[doc = ""]
    #[doc = " If not \\c NULL, the bitmap \\p cpuset will be filled with"]
    #[doc = " the set of PUs of this kind."]
    #[doc = ""]
    #[doc = " The integer pointed by \\p efficiency, if not \\c NULL will, be filled"]
    #[doc = " with the ranking of this kind of CPU in term of efficiency (see above)."]
    #[doc = " It ranges from \\c 0 to the number of kinds"]
    #[doc = " (as reported by hwloc_cpukinds_get_nr()) minus 1."]
    #[doc = ""]
    #[doc = " Kinds with lower efficiency are reported first."]
    #[doc = ""]
    #[doc = " If there is a single kind in the topology, its efficiency \\c 0."]
    #[doc = " If the efficiency of some kinds of cores is unknown,"]
    #[doc = " the efficiency of all kinds is set to \\c -1,"]
    #[doc = " and kinds are reported in no specific order."]
    #[doc = ""]
    #[doc = " The array of info attributes (for instance the \"CoreType\","]
    #[doc = " \"FrequencyMaxMHz\" or \"FrequencyBaseMHz\", see \\ref topoattrs_cpukinds)"]
    #[doc = " and its length are returned in \\p infos or \\p nr_infos."]
    #[doc = " The array belongs to the topology, it should not be freed or modified."]
    #[doc = ""]
    #[doc = " If \\p nr_infos or \\p infos is \\c NULL, no info is returned."]
    #[doc = ""]
    #[doc = " \\p flags must be \\c 0 for now."]
    #[doc = ""]
    #[doc = " \\return \\c 0 on success."]
    #[doc = " \\return \\c -1 with \\p errno set to \\c ENOENT if \\p kind_index does not match any CPU kind."]
    #[doc = " \\return \\c -1 with \\p errno set to \\c EINVAL if parameters are invalid."]
    pub fn hwloc_cpukinds_get_info(
        topology: hwloc_topology_t,
        kind_index: ::std::os::raw::c_uint,
        cpuset: hwloc_bitmap_t,
        efficiency: *mut ::std::os::raw::c_int,
        nr_infos: *mut ::std::os::raw::c_uint,
        infos: *mut *mut hwloc_info_s,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Register a kind of CPU in the topology."]
    #[doc = ""]
    #[doc = " Mark the PUs listed in \\p cpuset as being of the same kind"]
    #[doc = " with respect to the given attributes."]
    #[doc = ""]
    #[doc = " \\p forced_efficiency should be \\c -1 if unknown."]
    #[doc = " Otherwise it is an abstracted efficiency value to enforce"]
    #[doc = " the ranking of all kinds if all of them have valid (and"]
    #[doc = " different) efficiencies."]
    #[doc = ""]
    #[doc = " The array \\p infos of size \\p nr_infos may be used to provide"]
    #[doc = " info names and values describing this kind of PUs."]
    #[doc = ""]
    #[doc = " \\p flags must be \\c 0 for now."]
    #[doc = ""]
    #[doc = " Parameters \\p cpuset and \\p infos will be duplicated internally,"]
    #[doc = " the caller is responsible for freeing them."]
    #[doc = ""]
    #[doc = " If \\p cpuset overlaps with some existing kinds, those might get"]
    #[doc = " modified or split. For instance if existing kind A contains"]
    #[doc = " PUs 0 and 1, and one registers another kind for PU 1 and 2,"]
    #[doc = " there will be 3 resulting kinds:"]
    #[doc = " existing kind A is restricted to only PU 0;"]
    #[doc = " new kind B contains only PU 1 and combines information from A"]
    #[doc = " and from the newly-registered kind;"]
    #[doc = " new kind C contains only PU 2 and only gets information from"]
    #[doc = " the newly-registered kind."]
    #[doc = ""]
    #[doc = " \\note The efficiency \\p forced_efficiency provided to this function"]
    #[doc = " may be different from the one reported later by hwloc_cpukinds_get_info()"]
    #[doc = " because hwloc will scale efficiency values down to"]
    #[doc = " between 0 and the number of kinds minus 1."]
    #[doc = ""]
    #[doc = " \\return \\c 0 on success."]
    #[doc = " \\return \\c -1 with \\p errno set to \\c EINVAL if some parameters are invalid,"]
    #[doc = " for instance if \\p cpuset is \\c NULL or empty."]
    pub fn hwloc_cpukinds_register(
        topology: hwloc_topology_t,
        cpuset: hwloc_bitmap_t,
        forced_efficiency: ::std::os::raw::c_int,
        nr_infos: ::std::os::raw::c_uint,
        infos: *mut hwloc_info_s,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
#[doc = " \\brief Export XML that is loadable by hwloc v1.x."]
#[doc = " However, the export may miss some details about the topology."]
#[doc = " \\hideinitializer"]
pub const hwloc_topology_export_xml_flags_e_HWLOC_TOPOLOGY_EXPORT_XML_FLAG_V1:
    hwloc_topology_export_xml_flags_e = 1;
#[doc = " \\brief Flags for exporting XML topologies."]
#[doc = ""]
#[doc = " Flags to be given as a OR'ed set to hwloc_topology_export_xml()."]
pub type hwloc_topology_export_xml_flags_e = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " \\brief Export the topology into an XML file."]
    #[doc = ""]
    #[doc = " This file may be loaded later through hwloc_topology_set_xml()."]
    #[doc = ""]
    #[doc = " By default, the latest export format is used, which means older hwloc"]
    #[doc = " releases (e.g. v1.x) will not be able to import it."]
    #[doc = " Exporting to v1.x specific XML format is possible using flag"]
    #[doc = " ::HWLOC_TOPOLOGY_EXPORT_XML_FLAG_V1 but it may miss some details"]
    #[doc = " about the topology."]
    #[doc = " If there is any chance that the exported file may ever be imported"]
    #[doc = " back by a process using hwloc 1.x, one should consider detecting"]
    #[doc = " it at runtime and using the corresponding export format."]
    #[doc = ""]
    #[doc = " \\p flags is a OR'ed set of ::hwloc_topology_export_xml_flags_e."]
    #[doc = ""]
    #[doc = " \\return -1 if a failure occured."]
    #[doc = ""]
    #[doc = " \\note See also hwloc_topology_set_userdata_export_callback()"]
    #[doc = " for exporting application-specific object userdata."]
    #[doc = ""]
    #[doc = " \\note The topology-specific userdata pointer is ignored when exporting to XML."]
    #[doc = ""]
    #[doc = " \\note Only printable characters may be exported to XML string attributes."]
    #[doc = " Any other character, especially any non-ASCII character, will be silently"]
    #[doc = " dropped."]
    #[doc = ""]
    #[doc = " \\note If \\p name is \"-\", the XML output is sent to the standard output."]
    pub fn hwloc_topology_export_xml(
        topology: hwloc_topology_t,
        xmlpath: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Export the topology into a newly-allocated XML memory buffer."]
    #[doc = ""]
    #[doc = " \\p xmlbuffer is allocated by the callee and should be freed with"]
    #[doc = " hwloc_free_xmlbuffer() later in the caller."]
    #[doc = ""]
    #[doc = " This memory buffer may be loaded later through hwloc_topology_set_xmlbuffer()."]
    #[doc = ""]
    #[doc = " By default, the latest export format is used, which means older hwloc"]
    #[doc = " releases (e.g. v1.x) will not be able to import it."]
    #[doc = " Exporting to v1.x specific XML format is possible using flag"]
    #[doc = " ::HWLOC_TOPOLOGY_EXPORT_XML_FLAG_V1 but it may miss some details"]
    #[doc = " about the topology."]
    #[doc = " If there is any chance that the exported buffer may ever be imported"]
    #[doc = " back by a process using hwloc 1.x, one should consider detecting"]
    #[doc = " it at runtime and using the corresponding export format."]
    #[doc = ""]
    #[doc = " The returned buffer ends with a \\0 that is included in the returned"]
    #[doc = " length."]
    #[doc = ""]
    #[doc = " \\p flags is a OR'ed set of ::hwloc_topology_export_xml_flags_e."]
    #[doc = ""]
    #[doc = " \\return -1 if a failure occured."]
    #[doc = ""]
    #[doc = " \\note See also hwloc_topology_set_userdata_export_callback()"]
    #[doc = " for exporting application-specific object userdata."]
    #[doc = ""]
    #[doc = " \\note The topology-specific userdata pointer is ignored when exporting to XML."]
    #[doc = ""]
    #[doc = " \\note Only printable characters may be exported to XML string attributes."]
    #[doc = " Any other character, especially any non-ASCII character, will be silently"]
    #[doc = " dropped."]
    pub fn hwloc_topology_export_xmlbuffer(
        topology: hwloc_topology_t,
        xmlbuffer: *mut *mut ::std::os::raw::c_char,
        buflen: *mut ::std::os::raw::c_int,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Free a buffer allocated by hwloc_topology_export_xmlbuffer()"]
    pub fn hwloc_free_xmlbuffer(topology: hwloc_topology_t, xmlbuffer: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " \\brief Set the application-specific callback for exporting object userdata"]
    #[doc = ""]
    #[doc = " The object userdata pointer is not exported to XML by default because hwloc"]
    #[doc = " does not know what it contains."]
    #[doc = ""]
    #[doc = " This function lets applications set \\p export_cb to a callback function"]
    #[doc = " that converts this opaque userdata into an exportable string."]
    #[doc = ""]
    #[doc = " \\p export_cb is invoked during XML export for each object whose"]
    #[doc = " \\p userdata pointer is not \\c NULL."]
    #[doc = " The callback should use hwloc_export_obj_userdata() or"]
    #[doc = " hwloc_export_obj_userdata_base64() to actually export"]
    #[doc = " something to XML (possibly multiple times per object)."]
    #[doc = ""]
    #[doc = " \\p export_cb may be set to \\c NULL if userdata should not be exported to XML."]
    #[doc = ""]
    #[doc = " \\note The topology-specific userdata pointer is ignored when exporting to XML."]
    pub fn hwloc_topology_set_userdata_export_callback(
        topology: hwloc_topology_t,
        export_cb: ::std::option::Option<
            unsafe extern "C" fn(
                reserved: *mut ::std::os::raw::c_void,
                topology: hwloc_topology_t,
                obj: hwloc_obj_t,
            ),
        >,
    );
}
extern "C" {
    #[doc = " \\brief Export some object userdata to XML"]
    #[doc = ""]
    #[doc = " This function may only be called from within the export() callback passed"]
    #[doc = " to hwloc_topology_set_userdata_export_callback()."]
    #[doc = " It may be invoked one of multiple times to export some userdata to XML."]
    #[doc = " The \\p buffer content of length \\p length is stored with optional name"]
    #[doc = " \\p name."]
    #[doc = ""]
    #[doc = " When importing this XML file, the import() callback (if set) will be"]
    #[doc = " called exactly as many times as hwloc_export_obj_userdata() was called"]
    #[doc = " during export(). It will receive the corresponding \\p name, \\p buffer"]
    #[doc = " and \\p length arguments."]
    #[doc = ""]
    #[doc = " \\p reserved, \\p topology and \\p obj must be the first three parameters"]
    #[doc = " that were given to the export callback."]
    #[doc = ""]
    #[doc = " Only printable characters may be exported to XML string attributes."]
    #[doc = " If a non-printable character is passed in \\p name or \\p buffer,"]
    #[doc = " the function returns -1 with errno set to EINVAL."]
    #[doc = ""]
    #[doc = " If exporting binary data, the application should first encode into"]
    #[doc = " printable characters only (or use hwloc_export_obj_userdata_base64())."]
    #[doc = " It should also take care of portability issues if the export may"]
    #[doc = " be reimported on a different architecture."]
    pub fn hwloc_export_obj_userdata(
        reserved: *mut ::std::os::raw::c_void,
        topology: hwloc_topology_t,
        obj: hwloc_obj_t,
        name: *const ::std::os::raw::c_char,
        buffer: *const ::std::os::raw::c_void,
        length: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Encode and export some object userdata to XML"]
    #[doc = ""]
    #[doc = " This function is similar to hwloc_export_obj_userdata() but it encodes"]
    #[doc = " the input buffer into printable characters before exporting."]
    #[doc = " On import, decoding is automatically performed before the data is given"]
    #[doc = " to the import() callback if any."]
    #[doc = ""]
    #[doc = " This function may only be called from within the export() callback passed"]
    #[doc = " to hwloc_topology_set_userdata_export_callback()."]
    #[doc = ""]
    #[doc = " The function does not take care of portability issues if the export"]
    #[doc = " may be reimported on a different architecture."]
    pub fn hwloc_export_obj_userdata_base64(
        reserved: *mut ::std::os::raw::c_void,
        topology: hwloc_topology_t,
        obj: hwloc_obj_t,
        name: *const ::std::os::raw::c_char,
        buffer: *const ::std::os::raw::c_void,
        length: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Set the application-specific callback for importing userdata"]
    #[doc = ""]
    #[doc = " On XML import, userdata is ignored by default because hwloc does not know"]
    #[doc = " how to store it in memory."]
    #[doc = ""]
    #[doc = " This function lets applications set \\p import_cb to a callback function"]
    #[doc = " that will get the XML-stored userdata and store it in the object as expected"]
    #[doc = " by the application."]
    #[doc = ""]
    #[doc = " \\p import_cb is called during hwloc_topology_load() as many times as"]
    #[doc = " hwloc_export_obj_userdata() was called during export. The topology"]
    #[doc = " is not entirely setup yet. Object attributes are ready to consult,"]
    #[doc = " but links between objects are not."]
    #[doc = ""]
    #[doc = " \\p import_cb may be \\c NULL if userdata should be ignored during import."]
    #[doc = ""]
    #[doc = " \\note \\p buffer contains \\p length characters followed by a null byte ('\\0')."]
    #[doc = ""]
    #[doc = " \\note This function should be called before hwloc_topology_load()."]
    #[doc = ""]
    #[doc = " \\note The topology-specific userdata pointer is ignored when importing from XML."]
    pub fn hwloc_topology_set_userdata_import_callback(
        topology: hwloc_topology_t,
        import_cb: ::std::option::Option<
            unsafe extern "C" fn(
                topology: hwloc_topology_t,
                obj: hwloc_obj_t,
                name: *const ::std::os::raw::c_char,
                buffer: *const ::std::os::raw::c_void,
                length: size_t,
            ),
        >,
    );
}
#[doc = " \\brief Export extended types such as L2dcache as basic types such as Cache."]
#[doc = ""]
#[doc = " This is required if loading the synthetic description with hwloc < 1.9."]
#[doc = " \\hideinitializer"]
pub const hwloc_topology_export_synthetic_flags_e_HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_NO_EXTENDED_TYPES : hwloc_topology_export_synthetic_flags_e = 1 ;
#[doc = " \\brief Do not export level attributes."]
#[doc = ""]
#[doc = " Ignore level attributes such as memory/cache sizes or PU indexes."]
#[doc = " This is required if loading the synthetic description with hwloc < 1.10."]
#[doc = " \\hideinitializer"]
pub const hwloc_topology_export_synthetic_flags_e_HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_NO_ATTRS:
    hwloc_topology_export_synthetic_flags_e = 2;
#[doc = " \\brief Export the memory hierarchy as expected in hwloc 1.x."]
#[doc = ""]
#[doc = " Instead of attaching memory children to levels, export single NUMA node child"]
#[doc = " as normal intermediate levels, when possible."]
#[doc = " This is required if loading the synthetic description with hwloc 1.x."]
#[doc = " However this may fail if some objects have multiple local NUMA nodes."]
#[doc = " \\hideinitializer"]
pub const hwloc_topology_export_synthetic_flags_e_HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_V1:
    hwloc_topology_export_synthetic_flags_e = 4;
#[doc = " \\brief Do not export memory information."]
#[doc = ""]
#[doc = " Only export the actual hierarchy of normal CPU-side objects and ignore"]
#[doc = " where memory is attached."]
#[doc = " This is useful for when the hierarchy of CPUs is what really matters,"]
#[doc = " but it behaves as if there was a single machine-wide NUMA node."]
#[doc = " \\hideinitializer"]
pub const hwloc_topology_export_synthetic_flags_e_HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_IGNORE_MEMORY : hwloc_topology_export_synthetic_flags_e = 8 ;
#[doc = " \\brief Flags for exporting synthetic topologies."]
#[doc = ""]
#[doc = " Flags to be given as a OR'ed set to hwloc_topology_export_synthetic()."]
pub type hwloc_topology_export_synthetic_flags_e = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " \\brief Export the topology as a synthetic string."]
    #[doc = ""]
    #[doc = " At most \\p buflen characters will be written in \\p buffer,"]
    #[doc = " including the terminating \\0."]
    #[doc = ""]
    #[doc = " This exported string may be given back to hwloc_topology_set_synthetic()."]
    #[doc = ""]
    #[doc = " \\p flags is a OR'ed set of ::hwloc_topology_export_synthetic_flags_e."]
    #[doc = ""]
    #[doc = " \\return The number of characters that were written,"]
    #[doc = " not including the terminating \\0."]
    #[doc = ""]
    #[doc = " \\return -1 if the topology could not be exported,"]
    #[doc = " for instance if it is not symmetric."]
    #[doc = ""]
    #[doc = " \\note I/O and Misc children are ignored, the synthetic string only"]
    #[doc = " describes normal children."]
    #[doc = ""]
    #[doc = " \\note A 1024-byte buffer should be large enough for exporting"]
    #[doc = " topologies in the vast majority of cases."]
    pub fn hwloc_topology_export_synthetic(
        topology: hwloc_topology_t,
        buffer: *mut ::std::os::raw::c_char,
        buflen: size_t,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
#[doc = " \\brief Matrix of distances between a set of objects."]
#[doc = ""]
#[doc = " This matrix often contains latencies between NUMA nodes"]
#[doc = " (as reported in the System Locality Distance Information Table (SLIT)"]
#[doc = " in the ACPI specification), which may or may not be physically accurate."]
#[doc = " It corresponds to the latency for accessing the memory of one node"]
#[doc = " from a core in another node."]
#[doc = " The corresponding kind is ::HWLOC_DISTANCES_KIND_FROM_OS | ::HWLOC_DISTANCES_KIND_FROM_USER."]
#[doc = " The name of this distances structure is \"NUMALatency\"."]
#[doc = " Others distance structures include and \"XGMIBandwidth\", \"XGMIHops\""]
#[doc = " and \"NVLinkBandwidth\"."]
#[doc = ""]
#[doc = " The matrix may also contain bandwidths between random sets of objects,"]
#[doc = " possibly provided by the user, as specified in the \\p kind attribute."]
#[doc = ""]
#[doc = " Pointers \\p objs and \\p values should not be replaced, reallocated, freed, etc."]
#[doc = " However callers are allowed to modify \\p kind as well as the contents"]
#[doc = " of \\p objs and \\p values arrays."]
#[doc = " For instance, if there is a single NUMA node per Package,"]
#[doc = " hwloc_get_obj_with_same_locality() may be used to convert between them"]
#[doc = " and replace NUMA nodes in the \\p objs array with the corresponding Packages."]
#[doc = " See also hwloc_distances_transform() for applying some transformations"]
#[doc = " to the structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hwloc_distances_s {
    #[doc = "< \\brief Number of objects described by the distance matrix."]
    pub nbobjs: ::std::os::raw::c_uint,
    #[doc = "< \\brief Array of objects described by the distance matrix."]
    #[doc = " These objects are not in any particular order,"]
    #[doc = " see hwloc_distances_obj_index() and hwloc_distances_obj_pair_values()"]
    #[doc = " for easy ways to find objects in this array and their corresponding values."]
    pub objs: *mut hwloc_obj_t,
    #[doc = "< \\brief OR'ed set of ::hwloc_distances_kind_e."]
    pub kind: ::std::os::raw::c_ulong,
    #[doc = "< \\brief Matrix of distances between objects, stored as a one-dimension array."]
    #[doc = ""]
    #[doc = " Distance from i-th to j-th object is stored in slot i*nbobjs+j."]
    #[doc = " The meaning of the value depends on the \\p kind attribute."]
    pub values: *mut hwloc_uint64_t,
}
#[test]
fn bindgen_test_layout_hwloc_distances_s() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_distances_s>(),
        32usize,
        concat!("Size of: ", stringify!(hwloc_distances_s))
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_distances_s>(),
        8usize,
        concat!("Alignment of ", stringify!(hwloc_distances_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_distances_s>())).nbobjs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_distances_s),
            "::",
            stringify!(nbobjs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_distances_s>())).objs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_distances_s),
            "::",
            stringify!(objs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_distances_s>())).kind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_distances_s),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_distances_s>())).values as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_distances_s),
            "::",
            stringify!(values)
        )
    );
}
#[doc = " \\brief These distances were obtained from the operating system or hardware."]
#[doc = " \\hideinitializer"]
pub const hwloc_distances_kind_e_HWLOC_DISTANCES_KIND_FROM_OS: hwloc_distances_kind_e = 1;
#[doc = " \\brief These distances were provided by the user."]
#[doc = " \\hideinitializer"]
pub const hwloc_distances_kind_e_HWLOC_DISTANCES_KIND_FROM_USER: hwloc_distances_kind_e = 2;
#[doc = " \\brief Distance values are similar to latencies between objects."]
#[doc = " Values are smaller for closer objects, hence minimal on the diagonal"]
#[doc = " of the matrix (distance between an object and itself)."]
#[doc = " It could also be the number of network hops between objects, etc."]
#[doc = " \\hideinitializer"]
pub const hwloc_distances_kind_e_HWLOC_DISTANCES_KIND_MEANS_LATENCY: hwloc_distances_kind_e = 4;
#[doc = " \\brief Distance values are similar to bandwidths between objects."]
#[doc = " Values are higher for closer objects, hence maximal on the diagonal"]
#[doc = " of the matrix (distance between an object and itself)."]
#[doc = " Such values are currently ignored for distance-based grouping."]
#[doc = " \\hideinitializer"]
pub const hwloc_distances_kind_e_HWLOC_DISTANCES_KIND_MEANS_BANDWIDTH: hwloc_distances_kind_e = 8;
#[doc = " \\brief This distances structure covers objects of different types."]
#[doc = " This may apply to the \"NVLinkBandwidth\" structure in presence"]
#[doc = " of a NVSwitch or POWER processor NVLink port."]
#[doc = " \\hideinitializer"]
pub const hwloc_distances_kind_e_HWLOC_DISTANCES_KIND_HETEROGENEOUS_TYPES: hwloc_distances_kind_e =
    16;
#[doc = " \\brief Kinds of distance matrices."]
#[doc = ""]
#[doc = " The \\p kind attribute of struct hwloc_distances_s is a OR'ed set"]
#[doc = " of kinds."]
#[doc = ""]
#[doc = " A kind of format HWLOC_DISTANCES_KIND_FROM_* specifies where the"]
#[doc = " distance information comes from, if known."]
#[doc = ""]
#[doc = " A kind of format HWLOC_DISTANCES_KIND_MEANS_* specifies whether"]
#[doc = " values are latencies or bandwidths, if applicable."]
pub type hwloc_distances_kind_e = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " \\brief Retrieve distance matrices."]
    #[doc = ""]
    #[doc = " Retrieve distance matrices from the topology into the \\p distances array."]
    #[doc = ""]
    #[doc = " \\p flags is currently unused, should be \\c 0."]
    #[doc = ""]
    #[doc = " \\p kind serves as a filter. If \\c 0, all distance matrices are returned."]
    #[doc = " If it contains some HWLOC_DISTANCES_KIND_FROM_*, only distance matrices"]
    #[doc = " whose kind matches one of these are returned."]
    #[doc = " If it contains some HWLOC_DISTANCES_KIND_MEANS_*, only distance matrices"]
    #[doc = " whose kind matches one of these are returned."]
    #[doc = ""]
    #[doc = " On input, \\p nr points to the number of distance matrices that may be stored"]
    #[doc = " in \\p distances."]
    #[doc = " On output, \\p nr points to the number of distance matrices that were actually"]
    #[doc = " found, even if some of them couldn't be stored in \\p distances."]
    #[doc = " Distance matrices that couldn't be stored are ignored, but the function still"]
    #[doc = " returns success (\\c 0). The caller may find out by comparing the value pointed"]
    #[doc = " by \\p nr before and after the function call."]
    #[doc = ""]
    #[doc = " Each distance matrix returned in the \\p distances array should be released"]
    #[doc = " by the caller using hwloc_distances_release()."]
    pub fn hwloc_distances_get(
        topology: hwloc_topology_t,
        nr: *mut ::std::os::raw::c_uint,
        distances: *mut *mut hwloc_distances_s,
        kind: ::std::os::raw::c_ulong,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Retrieve distance matrices for object at a specific depth in the topology."]
    #[doc = ""]
    #[doc = " Identical to hwloc_distances_get() with the additional \\p depth filter."]
    pub fn hwloc_distances_get_by_depth(
        topology: hwloc_topology_t,
        depth: ::std::os::raw::c_int,
        nr: *mut ::std::os::raw::c_uint,
        distances: *mut *mut hwloc_distances_s,
        kind: ::std::os::raw::c_ulong,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Retrieve distance matrices for object of a specific type."]
    #[doc = ""]
    #[doc = " Identical to hwloc_distances_get() with the additional \\p type filter."]
    pub fn hwloc_distances_get_by_type(
        topology: hwloc_topology_t,
        type_: hwloc_obj_type_t,
        nr: *mut ::std::os::raw::c_uint,
        distances: *mut *mut hwloc_distances_s,
        kind: ::std::os::raw::c_ulong,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Retrieve a distance matrix with the given name."]
    #[doc = ""]
    #[doc = " Usually only one distances structure may match a given name."]
    #[doc = ""]
    #[doc = " The name of the most common structure is \"NUMALatency\"."]
    #[doc = " Others include \"XGMIBandwidth\", \"XGMIHops\" and \"NVLinkBandwidth\"."]
    pub fn hwloc_distances_get_by_name(
        topology: hwloc_topology_t,
        name: *const ::std::os::raw::c_char,
        nr: *mut ::std::os::raw::c_uint,
        distances: *mut *mut hwloc_distances_s,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get a description of what a distances structure contains."]
    #[doc = ""]
    #[doc = " For instance \"NUMALatency\" for hardware-provided NUMA distances (ACPI SLIT),"]
    #[doc = " or NULL if unknown."]
    pub fn hwloc_distances_get_name(
        topology: hwloc_topology_t,
        distances: *mut hwloc_distances_s,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " \\brief Release a distance matrix structure previously returned by hwloc_distances_get()."]
    #[doc = ""]
    #[doc = " \\note This function is not required if the structure is removed with hwloc_distances_release_remove()."]
    pub fn hwloc_distances_release(topology: hwloc_topology_t, distances: *mut hwloc_distances_s);
}
#[doc = " \\brief Remove \\c NULL objects from the distances structure."]
#[doc = ""]
#[doc = " Every object that was replaced with \\c NULL in the \\p objs array"]
#[doc = " is removed and the \\p values array is updated accordingly."]
#[doc = ""]
#[doc = " At least \\c 2 objects must remain, otherwise hwloc_distances_transform()"]
#[doc = " will return \\c -1 with \\p errno set to \\c EINVAL."]
#[doc = ""]
#[doc = " \\p kind will be updated with or without ::HWLOC_DISTANCES_KIND_HETEROGENEOUS_TYPES"]
#[doc = " according to the remaining objects."]
#[doc = ""]
#[doc = " \\hideinitializer"]
pub const hwloc_distances_transform_e_HWLOC_DISTANCES_TRANSFORM_REMOVE_NULL:
    hwloc_distances_transform_e = 0;
#[doc = " \\brief Replace bandwidth values with a number of links."]
#[doc = ""]
#[doc = " Usually all values will be either \\c 0 (no link) or \\c 1 (one link)."]
#[doc = " However some matrices could get larger values if some pairs of"]
#[doc = " peers are connected by different numbers of links."]
#[doc = ""]
#[doc = " Values on the diagonal are set to \\c 0."]
#[doc = ""]
#[doc = " This transformation only applies to bandwidth matrices."]
#[doc = ""]
#[doc = " \\hideinitializer"]
pub const hwloc_distances_transform_e_HWLOC_DISTANCES_TRANSFORM_LINKS: hwloc_distances_transform_e =
    1;
#[doc = " \\brief Merge switches with multiple ports into a single object."]
#[doc = " This currently only applies to NVSwitches where GPUs seem connected to different"]
#[doc = " separate switch ports in the NVLinkBandwidth matrix. This transformation will"]
#[doc = " replace all of them with the same port connected to all GPUs."]
#[doc = " Other ports are removed by applying ::HWLOC_DISTANCES_TRANSFORM_REMOVE_NULL internally."]
#[doc = " \\hideinitializer"]
pub const hwloc_distances_transform_e_HWLOC_DISTANCES_TRANSFORM_MERGE_SWITCH_PORTS:
    hwloc_distances_transform_e = 2;
#[doc = " \\brief Apply a transitive closure to the matrix to connect objects across switches."]
#[doc = " This currently only applies to GPUs and NVSwitches in the NVLinkBandwidth matrix."]
#[doc = " All pairs of GPUs will be reported as directly connected."]
#[doc = " \\hideinitializer"]
pub const hwloc_distances_transform_e_HWLOC_DISTANCES_TRANSFORM_TRANSITIVE_CLOSURE:
    hwloc_distances_transform_e = 3;
#[doc = " \\brief Transformations of distances structures."]
pub type hwloc_distances_transform_e = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " \\brief Apply a transformation to a distances structure."]
    #[doc = ""]
    #[doc = " Modify a distances structure that was previously obtained with"]
    #[doc = " hwloc_distances_get() or one of its variants."]
    #[doc = ""]
    #[doc = " This modifies the local copy of the distances structures but does"]
    #[doc = " not modify the distances information stored inside the topology"]
    #[doc = " (retrieved by another call to hwloc_distances_get() or exported to XML)."]
    #[doc = " To do so, one should add a new distances structure with same"]
    #[doc = " name, kind, objects and values (see \\ref hwlocality_distances_add)"]
    #[doc = " and then remove this old one with hwloc_distances_release_remove()."]
    #[doc = ""]
    #[doc = " \\p transform must be one of the transformations listed"]
    #[doc = " in ::hwloc_distances_transform_e."]
    #[doc = ""]
    #[doc = " These transformations may modify the contents of the \\p objs or \\p values arrays."]
    #[doc = ""]
    #[doc = " \\p transform_attr must be \\c NULL for now."]
    #[doc = ""]
    #[doc = " \\p flags must be \\c 0 for now."]
    #[doc = ""]
    #[doc = " \\note Objects in distances array \\p objs may be directly modified"]
    #[doc = " in place without using hwloc_distances_transform()."]
    #[doc = " One may use hwloc_get_obj_with_same_locality() to easily convert"]
    #[doc = " between similar objects of different types."]
    pub fn hwloc_distances_transform(
        topology: hwloc_topology_t,
        distances: *mut hwloc_distances_s,
        transform: hwloc_distances_transform_e,
        transform_attr: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
#[doc = " \\brief Handle to a new distances structure during its addition to the topology."]
pub type hwloc_distances_add_handle_t = *mut ::std::os::raw::c_void;
extern "C" {
    #[doc = " \\brief Create a new empty distances structure."]
    #[doc = ""]
    #[doc = " Create an empty distances structure"]
    #[doc = " to be filled with hwloc_distances_add_values()"]
    #[doc = " and then committed with hwloc_distances_add_commit()."]
    #[doc = ""]
    #[doc = " Parameter \\p name is optional, it may be \\c NULL."]
    #[doc = " Otherwise, it will be copied internally and may later be freed by the caller."]
    #[doc = ""]
    #[doc = " \\p kind specifies the kind of distance as a OR'ed set of ::hwloc_distances_kind_e."]
    #[doc = " Kind ::HWLOC_DISTANCES_KIND_HETEROGENEOUS_TYPES will be automatically set"]
    #[doc = " according to objects having different types in hwloc_distances_add_values()."]
    #[doc = ""]
    #[doc = " \\p flags must be \\c 0 for now."]
    #[doc = ""]
    #[doc = " \\return A hwloc_distances_add_handle_t that should then be passed"]
    #[doc = " to hwloc_distances_add_values() and hwloc_distances_add_commit()."]
    #[doc = ""]
    #[doc = " \\return \\c NULL on error."]
    pub fn hwloc_distances_add_create(
        topology: hwloc_topology_t,
        name: *const ::std::os::raw::c_char,
        kind: ::std::os::raw::c_ulong,
        flags: ::std::os::raw::c_ulong,
    ) -> hwloc_distances_add_handle_t;
}
extern "C" {
    #[doc = " \\brief Specify the objects and values in a new empty distances structure."]
    #[doc = ""]
    #[doc = " Specify the objects and values for a new distances structure"]
    #[doc = " that was returned as a handle by hwloc_distances_add_create()."]
    #[doc = " The structure must then be committed with hwloc_distances_add_commit()."]
    #[doc = ""]
    #[doc = " The number of objects is \\p nbobjs and the array of objects is \\p objs."]
    #[doc = " Distance values are stored as a one-dimension array in \\p values."]
    #[doc = " The distance from object i to object j is in slot i*nbobjs+j."]
    #[doc = ""]
    #[doc = " \\p nbobjs must be at least 2."]
    #[doc = ""]
    #[doc = " Arrays \\p objs and \\p values will be copied internally,"]
    #[doc = " they may later be freed by the caller."]
    #[doc = ""]
    #[doc = " On error, the temporary distances structure and its content are destroyed."]
    #[doc = ""]
    #[doc = " \\p flags must be \\c 0 for now."]
    #[doc = ""]
    #[doc = " \\return \\c 0 on success."]
    #[doc = " \\return \\c -1 on error."]
    pub fn hwloc_distances_add_values(
        topology: hwloc_topology_t,
        handle: hwloc_distances_add_handle_t,
        nbobjs: ::std::os::raw::c_uint,
        objs: *mut hwloc_obj_t,
        values: *mut hwloc_uint64_t,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
#[doc = " \\brief Try to group objects based on the newly provided distance information."]
#[doc = " This is ignored for distances between objects of different types."]
#[doc = " \\hideinitializer"]
pub const hwloc_distances_add_flag_e_HWLOC_DISTANCES_ADD_FLAG_GROUP: hwloc_distances_add_flag_e = 1;
#[doc = " \\brief If grouping, consider the distance values as inaccurate and relax the"]
#[doc = " comparisons during the grouping algorithms. The actual accuracy may be modified"]
#[doc = " through the HWLOC_GROUPING_ACCURACY environment variable (see \\ref envvar)."]
#[doc = " \\hideinitializer"]
pub const hwloc_distances_add_flag_e_HWLOC_DISTANCES_ADD_FLAG_GROUP_INACCURATE:
    hwloc_distances_add_flag_e = 2;
#[doc = " \\brief Flags for adding a new distances to a topology."]
pub type hwloc_distances_add_flag_e = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " \\brief Commit a new distances structure."]
    #[doc = ""]
    #[doc = " This function finalizes the distances structure and inserts in it the topology."]
    #[doc = ""]
    #[doc = " Parameter \\p handle was previously returned by hwloc_distances_add_create()."]
    #[doc = " Then objects and values were specified with hwloc_distances_add_values()."]
    #[doc = ""]
    #[doc = " \\p flags configures the behavior of the function using an optional OR'ed set of"]
    #[doc = " ::hwloc_distances_add_flag_e."]
    #[doc = " It may be used to request the grouping of existing objects based on distances."]
    #[doc = ""]
    #[doc = " On error, the temporary distances structure and its content are destroyed."]
    #[doc = ""]
    #[doc = " \\return \\c 0 on success."]
    #[doc = " \\return \\c -1 on error."]
    pub fn hwloc_distances_add_commit(
        topology: hwloc_topology_t,
        handle: hwloc_distances_add_handle_t,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Remove all distance matrices from a topology."]
    #[doc = ""]
    #[doc = " Remove all distance matrices, either provided by the user or"]
    #[doc = " gathered through the OS."]
    #[doc = ""]
    #[doc = " If these distances were used to group objects, these additional"]
    #[doc = " Group objects are not removed from the topology."]
    pub fn hwloc_distances_remove(topology: hwloc_topology_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Remove distance matrices for objects at a specific depth in the topology."]
    #[doc = ""]
    #[doc = " Identical to hwloc_distances_remove() but only applies to one level of the topology."]
    pub fn hwloc_distances_remove_by_depth(
        topology: hwloc_topology_t,
        depth: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Release and remove the given distance matrice from the topology."]
    #[doc = ""]
    #[doc = " This function includes a call to hwloc_distances_release()."]
    pub fn hwloc_distances_release_remove(
        topology: hwloc_topology_t,
        distances: *mut hwloc_distances_s,
    ) -> ::std::os::raw::c_int;
}
#[doc = " \\brief The object local memory is modified."]
#[doc = " The union is a hwloc_topology_diff_obj_attr_u::hwloc_topology_diff_obj_attr_uint64_s"]
#[doc = " (and the index field is ignored)."]
pub const hwloc_topology_diff_obj_attr_type_e_HWLOC_TOPOLOGY_DIFF_OBJ_ATTR_SIZE:
    hwloc_topology_diff_obj_attr_type_e = 0;
#[doc = " \\brief The object name is modified."]
#[doc = " The union is a hwloc_topology_diff_obj_attr_u::hwloc_topology_diff_obj_attr_string_s"]
#[doc = " (and the name field is ignored)."]
pub const hwloc_topology_diff_obj_attr_type_e_HWLOC_TOPOLOGY_DIFF_OBJ_ATTR_NAME:
    hwloc_topology_diff_obj_attr_type_e = 1;
#[doc = " \\brief the value of an info attribute is modified."]
#[doc = " The union is a hwloc_topology_diff_obj_attr_u::hwloc_topology_diff_obj_attr_string_s."]
pub const hwloc_topology_diff_obj_attr_type_e_HWLOC_TOPOLOGY_DIFF_OBJ_ATTR_INFO:
    hwloc_topology_diff_obj_attr_type_e = 2;
#[doc = " \\brief Type of one object attribute difference."]
pub type hwloc_topology_diff_obj_attr_type_e = ::std::os::raw::c_uint;
#[doc = " \\brief Type of one object attribute difference."]
pub use self::hwloc_topology_diff_obj_attr_type_e as hwloc_topology_diff_obj_attr_type_t;
#[doc = " \\brief One object attribute difference."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union hwloc_topology_diff_obj_attr_u {
    pub generic: hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_generic_s,
    pub uint64: hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_uint64_s,
    pub string: hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_string_s,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_generic_s {
    pub type_: hwloc_topology_diff_obj_attr_type_t,
}
#[test]
fn bindgen_test_layout_hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_generic_s() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_generic_s>(
        ),
        4usize,
        concat!(
            "Size of: ",
            stringify!(hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_generic_s)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_generic_s>(
        ),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_generic_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_generic_s,
            >()))
            .type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_generic_s),
            "::",
            stringify!(type_)
        )
    );
}
#[doc = " \\brief Integer attribute modification with an optional index."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_uint64_s {
    pub type_: hwloc_topology_diff_obj_attr_type_t,
    pub index: hwloc_uint64_t,
    pub oldvalue: hwloc_uint64_t,
    pub newvalue: hwloc_uint64_t,
}
#[test]
fn bindgen_test_layout_hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_uint64_s() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_uint64_s>(
        ),
        32usize,
        concat!(
            "Size of: ",
            stringify!(hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_uint64_s)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_uint64_s>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_uint64_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_uint64_s,
            >()))
            .type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_uint64_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_uint64_s,
            >()))
            .index as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_uint64_s),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_uint64_s,
            >()))
            .oldvalue as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_uint64_s),
            "::",
            stringify!(oldvalue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_uint64_s,
            >()))
            .newvalue as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_uint64_s),
            "::",
            stringify!(newvalue)
        )
    );
}
#[doc = " \\brief String attribute modification with an optional name"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_string_s {
    pub type_: hwloc_topology_diff_obj_attr_type_t,
    pub name: *mut ::std::os::raw::c_char,
    pub oldvalue: *mut ::std::os::raw::c_char,
    pub newvalue: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_string_s() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_string_s>(
        ),
        32usize,
        concat!(
            "Size of: ",
            stringify!(hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_string_s)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_string_s>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_string_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_string_s,
            >()))
            .type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_string_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_string_s,
            >()))
            .name as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_string_s),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_string_s,
            >()))
            .oldvalue as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_string_s),
            "::",
            stringify!(oldvalue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_string_s,
            >()))
            .newvalue as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_string_s),
            "::",
            stringify!(newvalue)
        )
    );
}
#[test]
fn bindgen_test_layout_hwloc_topology_diff_obj_attr_u() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_topology_diff_obj_attr_u>(),
        32usize,
        concat!("Size of: ", stringify!(hwloc_topology_diff_obj_attr_u))
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_topology_diff_obj_attr_u>(),
        8usize,
        concat!("Alignment of ", stringify!(hwloc_topology_diff_obj_attr_u))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_diff_obj_attr_u>())).generic as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_diff_obj_attr_u),
            "::",
            stringify!(generic)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_diff_obj_attr_u>())).uint64 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_diff_obj_attr_u),
            "::",
            stringify!(uint64)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_diff_obj_attr_u>())).string as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_diff_obj_attr_u),
            "::",
            stringify!(string)
        )
    );
}
#[doc = " \\brief An object attribute was changed."]
#[doc = " The union is a hwloc_topology_diff_u::hwloc_topology_diff_obj_attr_s."]
pub const hwloc_topology_diff_type_e_HWLOC_TOPOLOGY_DIFF_OBJ_ATTR: hwloc_topology_diff_type_e = 0;
#[doc = " \\brief The difference is too complex,"]
#[doc = " it cannot be represented. The difference below"]
#[doc = " this object has not been checked."]
#[doc = " hwloc_topology_diff_build() will return 1."]
#[doc = ""]
#[doc = " The union is a hwloc_topology_diff_u::hwloc_topology_diff_too_complex_s."]
pub const hwloc_topology_diff_type_e_HWLOC_TOPOLOGY_DIFF_TOO_COMPLEX: hwloc_topology_diff_type_e =
    1;
#[doc = " \\brief Type of one element of a difference list."]
pub type hwloc_topology_diff_type_e = ::std::os::raw::c_uint;
#[doc = " \\brief Type of one element of a difference list."]
pub use self::hwloc_topology_diff_type_e as hwloc_topology_diff_type_t;
#[doc = " \\brief One element of a difference list between two topologies."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union hwloc_topology_diff_u {
    pub generic: hwloc_topology_diff_u_hwloc_topology_diff_generic_s,
    pub obj_attr: hwloc_topology_diff_u_hwloc_topology_diff_obj_attr_s,
    pub too_complex: hwloc_topology_diff_u_hwloc_topology_diff_too_complex_s,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hwloc_topology_diff_u_hwloc_topology_diff_generic_s {
    pub type_: hwloc_topology_diff_type_t,
    pub next: *mut hwloc_topology_diff_u,
}
#[test]
fn bindgen_test_layout_hwloc_topology_diff_u_hwloc_topology_diff_generic_s() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_topology_diff_u_hwloc_topology_diff_generic_s>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(hwloc_topology_diff_u_hwloc_topology_diff_generic_s)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_topology_diff_u_hwloc_topology_diff_generic_s>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hwloc_topology_diff_u_hwloc_topology_diff_generic_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_diff_u_hwloc_topology_diff_generic_s>())).type_
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_diff_u_hwloc_topology_diff_generic_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_diff_u_hwloc_topology_diff_generic_s>())).next
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_diff_u_hwloc_topology_diff_generic_s),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hwloc_topology_diff_u_hwloc_topology_diff_obj_attr_s {
    pub type_: hwloc_topology_diff_type_t,
    pub next: *mut hwloc_topology_diff_u,
    pub obj_depth: ::std::os::raw::c_int,
    pub obj_index: ::std::os::raw::c_uint,
    pub diff: hwloc_topology_diff_obj_attr_u,
}
#[test]
fn bindgen_test_layout_hwloc_topology_diff_u_hwloc_topology_diff_obj_attr_s() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_topology_diff_u_hwloc_topology_diff_obj_attr_s>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(hwloc_topology_diff_u_hwloc_topology_diff_obj_attr_s)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_topology_diff_u_hwloc_topology_diff_obj_attr_s>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hwloc_topology_diff_u_hwloc_topology_diff_obj_attr_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_diff_u_hwloc_topology_diff_obj_attr_s>())).type_
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_diff_u_hwloc_topology_diff_obj_attr_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_diff_u_hwloc_topology_diff_obj_attr_s>())).next
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_diff_u_hwloc_topology_diff_obj_attr_s),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_diff_u_hwloc_topology_diff_obj_attr_s>()))
                .obj_depth as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_diff_u_hwloc_topology_diff_obj_attr_s),
            "::",
            stringify!(obj_depth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_diff_u_hwloc_topology_diff_obj_attr_s>()))
                .obj_index as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_diff_u_hwloc_topology_diff_obj_attr_s),
            "::",
            stringify!(obj_index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_diff_u_hwloc_topology_diff_obj_attr_s>())).diff
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_diff_u_hwloc_topology_diff_obj_attr_s),
            "::",
            stringify!(diff)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hwloc_topology_diff_u_hwloc_topology_diff_too_complex_s {
    pub type_: hwloc_topology_diff_type_t,
    pub next: *mut hwloc_topology_diff_u,
    pub obj_depth: ::std::os::raw::c_int,
    pub obj_index: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_hwloc_topology_diff_u_hwloc_topology_diff_too_complex_s() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_topology_diff_u_hwloc_topology_diff_too_complex_s>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(hwloc_topology_diff_u_hwloc_topology_diff_too_complex_s)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_topology_diff_u_hwloc_topology_diff_too_complex_s>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hwloc_topology_diff_u_hwloc_topology_diff_too_complex_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_diff_u_hwloc_topology_diff_too_complex_s>()))
                .type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_diff_u_hwloc_topology_diff_too_complex_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_diff_u_hwloc_topology_diff_too_complex_s>())).next
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_diff_u_hwloc_topology_diff_too_complex_s),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_diff_u_hwloc_topology_diff_too_complex_s>()))
                .obj_depth as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_diff_u_hwloc_topology_diff_too_complex_s),
            "::",
            stringify!(obj_depth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_diff_u_hwloc_topology_diff_too_complex_s>()))
                .obj_index as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_diff_u_hwloc_topology_diff_too_complex_s),
            "::",
            stringify!(obj_index)
        )
    );
}
#[test]
fn bindgen_test_layout_hwloc_topology_diff_u() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_topology_diff_u>(),
        56usize,
        concat!("Size of: ", stringify!(hwloc_topology_diff_u))
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_topology_diff_u>(),
        8usize,
        concat!("Alignment of ", stringify!(hwloc_topology_diff_u))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_topology_diff_u>())).generic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_diff_u),
            "::",
            stringify!(generic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_topology_diff_u>())).obj_attr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_diff_u),
            "::",
            stringify!(obj_attr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_diff_u>())).too_complex as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_diff_u),
            "::",
            stringify!(too_complex)
        )
    );
}
pub type hwloc_topology_diff_t = *mut hwloc_topology_diff_u;
extern "C" {
    #[doc = " \\brief Compute the difference between 2 topologies."]
    #[doc = ""]
    #[doc = " The difference is stored as a list of ::hwloc_topology_diff_t entries"]
    #[doc = " starting at \\p diff."]
    #[doc = " It is computed by doing a depth-first traversal of both topology trees"]
    #[doc = " simultaneously."]
    #[doc = ""]
    #[doc = " If the difference between 2 objects is too complex to be represented"]
    #[doc = " (for instance if some objects have different types, or different numbers"]
    #[doc = " of children), a special diff entry of type ::HWLOC_TOPOLOGY_DIFF_TOO_COMPLEX"]
    #[doc = " is queued."]
    #[doc = " The computation of the diff does not continue below these objects."]
    #[doc = " So each such diff entry means that the difference between two subtrees"]
    #[doc = " could not be computed."]
    #[doc = ""]
    #[doc = " \\return 0 if the difference can be represented properly."]
    #[doc = ""]
    #[doc = " \\return 0 with \\p diff pointing to NULL if there is no difference"]
    #[doc = " between the topologies."]
    #[doc = ""]
    #[doc = " \\return 1 if the difference is too complex (see above). Some entries in"]
    #[doc = " the list will be of type ::HWLOC_TOPOLOGY_DIFF_TOO_COMPLEX."]
    #[doc = ""]
    #[doc = " \\return -1 on any other error."]
    #[doc = ""]
    #[doc = " \\note \\p flags is currently not used. It should be 0."]
    #[doc = ""]
    #[doc = " \\note The output diff has to be freed with hwloc_topology_diff_destroy()."]
    #[doc = ""]
    #[doc = " \\note The output diff can only be exported to XML or passed to"]
    #[doc = " hwloc_topology_diff_apply() if 0 was returned, i.e. if no entry of type"]
    #[doc = " ::HWLOC_TOPOLOGY_DIFF_TOO_COMPLEX is listed."]
    #[doc = ""]
    #[doc = " \\note The output diff may be modified by removing some entries from"]
    #[doc = " the list. The removed entries should be freed by passing them to"]
    #[doc = " to hwloc_topology_diff_destroy() (possible as another list)."]
    pub fn hwloc_topology_diff_build(
        topology: hwloc_topology_t,
        newtopology: hwloc_topology_t,
        flags: ::std::os::raw::c_ulong,
        diff: *mut hwloc_topology_diff_t,
    ) -> ::std::os::raw::c_int;
}
#[doc = " \\brief Apply topology diff in reverse direction."]
#[doc = " \\hideinitializer"]
pub const hwloc_topology_diff_apply_flags_e_HWLOC_TOPOLOGY_DIFF_APPLY_REVERSE:
    hwloc_topology_diff_apply_flags_e = 1;
#[doc = " \\brief Flags to be given to hwloc_topology_diff_apply()."]
pub type hwloc_topology_diff_apply_flags_e = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " \\brief Apply a topology diff to an existing topology."]
    #[doc = ""]
    #[doc = " \\p flags is an OR'ed set of ::hwloc_topology_diff_apply_flags_e."]
    #[doc = ""]
    #[doc = " The new topology is modified in place. hwloc_topology_dup()"]
    #[doc = " may be used to duplicate it before patching."]
    #[doc = ""]
    #[doc = " If the difference cannot be applied entirely, all previous applied"]
    #[doc = " elements are unapplied before returning."]
    #[doc = ""]
    #[doc = " \\return 0 on success."]
    #[doc = ""]
    #[doc = " \\return -N if applying the difference failed while trying"]
    #[doc = " to apply the N-th part of the difference. For instance -1"]
    #[doc = " is returned if the very first difference element could not"]
    #[doc = " be applied."]
    pub fn hwloc_topology_diff_apply(
        topology: hwloc_topology_t,
        diff: hwloc_topology_diff_t,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Destroy a list of topology differences."]
    pub fn hwloc_topology_diff_destroy(diff: hwloc_topology_diff_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Load a list of topology differences from a XML file."]
    #[doc = ""]
    #[doc = " If not \\c NULL, \\p refname will be filled with the identifier"]
    #[doc = " string of the reference topology for the difference file,"]
    #[doc = " if any was specified in the XML file."]
    #[doc = " This identifier is usually the name of the other XML file"]
    #[doc = " that contains the reference topology."]
    #[doc = ""]
    #[doc = " \\note the pointer returned in refname should later be freed"]
    #[doc = " by the caller."]
    pub fn hwloc_topology_diff_load_xml(
        xmlpath: *const ::std::os::raw::c_char,
        diff: *mut hwloc_topology_diff_t,
        refname: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Export a list of topology differences to a XML file."]
    #[doc = ""]
    #[doc = " If not \\c NULL, \\p refname defines an identifier string"]
    #[doc = " for the reference topology which was used as a base when"]
    #[doc = " computing this difference."]
    #[doc = " This identifier is usually the name of the other XML file"]
    #[doc = " that contains the reference topology."]
    #[doc = " This attribute is given back when reading the diff from XML."]
    pub fn hwloc_topology_diff_export_xml(
        diff: hwloc_topology_diff_t,
        refname: *const ::std::os::raw::c_char,
        xmlpath: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Load a list of topology differences from a XML buffer."]
    #[doc = ""]
    #[doc = " If not \\c NULL, \\p refname will be filled with the identifier"]
    #[doc = " string of the reference topology for the difference file,"]
    #[doc = " if any was specified in the XML file."]
    #[doc = " This identifier is usually the name of the other XML file"]
    #[doc = " that contains the reference topology."]
    #[doc = ""]
    #[doc = " \\note the pointer returned in refname should later be freed"]
    #[doc = " by the caller."]
    pub fn hwloc_topology_diff_load_xmlbuffer(
        xmlbuffer: *const ::std::os::raw::c_char,
        buflen: ::std::os::raw::c_int,
        diff: *mut hwloc_topology_diff_t,
        refname: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Export a list of topology differences to a XML buffer."]
    #[doc = ""]
    #[doc = " If not \\c NULL, \\p refname defines an identifier string"]
    #[doc = " for the reference topology which was used as a base when"]
    #[doc = " computing this difference."]
    #[doc = " This identifier is usually the name of the other XML file"]
    #[doc = " that contains the reference topology."]
    #[doc = " This attribute is given back when reading the diff from XML."]
    #[doc = ""]
    #[doc = " The returned buffer ends with a \\0 that is included in the returned"]
    #[doc = " length."]
    #[doc = ""]
    #[doc = " \\note The XML buffer should later be freed with hwloc_free_xmlbuffer()."]
    pub fn hwloc_topology_diff_export_xmlbuffer(
        diff: hwloc_topology_diff_t,
        refname: *const ::std::os::raw::c_char,
        xmlbuffer: *mut *mut ::std::os::raw::c_char,
        buflen: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Add a distances structure."]
    #[doc = ""]
    #[doc = " Superseded by hwloc_distances_add_create()+hwloc_distances_add_values()+hwloc_distances_add_commit()"]
    #[doc = " in v2.5."]
    pub fn hwloc_distances_add(
        topology: hwloc_topology_t,
        nbobjs: ::std::os::raw::c_uint,
        objs: *mut hwloc_obj_t,
        values: *mut hwloc_uint64_t,
        kind: ::std::os::raw::c_ulong,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
